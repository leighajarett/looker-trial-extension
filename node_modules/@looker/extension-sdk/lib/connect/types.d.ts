import { ChattyHostConnection } from '@looker/chatty';
/**
 * Extension event used for chatty communication
 */
export declare enum ExtensionEvent {
    /**
     * Notification from host to client
     */
    EXTENSION_HOST_NOTIFICATION = "EXTENSION_NOTIFICATION",
    /**
     * Process request from client. This is actually a sendAndRecieve request
     */
    EXTENSION_API_REQUEST = "EXTENSION_API_REQUEST"
}
/**
 * Request types used by the underlying API. The ENTENSION_API_REQUEST delegates
 * work based upon the request type
 */
export declare enum ExtensionRequestType {
    /**
     * Verify that the host exists and is working correctly. Host is the Looker window
     * instance that owns the client IFRAME.
     */
    VERIFY_HOST = "VERIFY_HOST",
    /**
     * Execute a call on the Looker CORE SDK
     */
    INVOKE_CORE_SDK = "INVOKE_CORE_SDK",
    /**
     * Update title
     */
    UPDATE_TITLE = "UPDATE_TITLE",
    /**
     * Update location
     */
    UPDATE_LOCATION = "UPDATE_LOCATION",
    /**
     * Location route changed
     */
    ROUTE_CHANGED = "ROUTE_CHANGED",
    /**
     * Close popovers in the looker host
     */
    CLOSE_HOST_POPOVERS = "CLOSE_HOST_POPOVERS",
    /**
     * Local storage request
     */
    LOCAL_STORAGE = "LOCAL_STORAGE",
    /**
     * Track action
     */
    TRACK_ACTION = "TRACK_ACTION",
    /**
     * Error event
     */
    ERROR_EVENT = "ERROR_EVENT",
    /**
     * Invoke external API
     */
    INVOKE_EXTERNAL_API = "INVOKE_EXTERNAL_API",
    /**
     * Extension unloaded
     */
    EXTENSION_UNLOADED = "EXTENSION_UNLOADED"
}
/**
 * The message that is associated with the Chatty EXTENSION_API_REQUEST event
 */
export interface ExtensionRequest {
    /**
     * Extension request type
     */
    type: ExtensionRequestType;
    /**
     * Optional payload assocoayed with extension request type
     */
    payload?: InvokeCoreSdkRequest | undefined;
}
export declare enum ApiVersion {
    sdk31 = "3.1",
    sdk40 = "4.0"
}
export interface InvokeCoreSdkRequest {
    apiMethodName?: string;
    httpMethod?: string;
    path?: string;
    body?: any;
    params?: any;
    options?: any;
    apiVersion?: ApiVersion;
}
export interface UpdateTitleRequest {
    title: string;
}
export interface UpdateLocationRequest {
    url: string;
    state?: any;
}
export interface ExtensionHostApi extends ExtensionSDK {
    handleNotification(message: ExtensionNotification): any | void;
    invokeCoreSdkByPath(httpMethod: string, path: string, body?: any, params?: any, authenticator?: any, options?: any, apiVersion?: ApiVersion): Promise<any>;
    unloaded(): void;
}
export interface ExtensionClientApi {
    handleRequest(message: ExtensionRequest): any | void;
}
export interface RouteChangeRequest {
    route: string;
}
export interface LocalStorageRequest {
    type: 'get' | 'set' | 'remove';
    name: string;
    value?: string;
}
export interface TrackActionRequest {
    name: string;
    trackAction: string;
    attributes?: Record<string, any>;
}
export interface ErrorEventRequest {
    errorEvent: ErrorEvent;
}
export declare enum FetchResponseBodyType {
    arrayBuffer = 0,
    blob = 1,
    formData = 2,
    json = 3,
    text = 4
}
export interface FetchDataRequest {
    resource: string;
    init?: Record<string, any>;
    responseBodyType?: FetchResponseBodyType;
}
/**
 * Notification type
 */
export declare enum ExtensionNotificationType {
    /**
     * Route change message sent when the route changes in the host
     * (browser forward or back buttons)
     */
    ROUTE_CHANGED = "ROUTE_CHANGED",
    /**
     * Initialize message sent when chatty host and client have established
     * communication
     */
    INITIALIZE = "INITIALIZE"
}
/**
 * Route change data
 */
export interface RouteChangeData {
    /**
     * Changed route for the extension
     */
    route?: string;
    /**
     * Changed route state
     */
    routeState?: any;
}
/**
 * Initialization data. Looker host data.
 */
export interface LookerHostData {
    /**
     * Version of looker
     */
    lookerVersion: string;
    /**
     * Initial route for the extension
     */
    route?: string;
    /**
     * route state
     */
    routeState?: any;
    /**
     * hostUrl url of Looker host
     */
    hostUrl?: string;
}
/**
 * Extension notification
 */
export interface ExtensionNotification {
    type: ExtensionNotificationType;
    payload?: LookerHostData | RouteChangeData | undefined;
}
/**
 * Extension host configuration
 */
export interface ExtensionHostConfiguration {
    /**
     * Callback once extension initialized
     * @param errorMessage details of any errors that have
     *  occured during initialization
     */
    initializedCallback?: (errorMessage?: string) => void;
    /**
     * Callback to set the initial route to be restored. Ignored if
     * route tracking off
     */
    setInitialRoute?: (route: string, routeState?: any) => void;
    /**
     * Required looker version. An error will be thrown if the host
     * Looker is not at the version specified.
     */
    requiredLookerVersion?: string;
    /**
     * Callback to notify extension that host has changed the route.
     * The host changes the route when browser back or forward button
     * pressed.
     */
    hostChangedRoute?: (route: string, routeState?: any) => void;
}
export interface ExtensionHostApiConfiguration extends ExtensionHostConfiguration {
    chattyHost: ChattyHostConnection;
}
/**
 * Custom parameters for fetch proxy
 */
export interface FetchCustomParameters {
    /**
     * Http method
     */
    method?: 'POST' | 'GET' | 'DELETE' | 'PATCH' | 'PUT' | 'HEAD';
    /**
     * Request headers
     */
    headers?: Record<string, string>;
    /**
     * Request body
     */
    body?: string;
}
/**
 * Public extension SDK
 */
export interface ExtensionSDK {
    /**
     * Looker host data
     */
    lookerHostData?: Readonly<LookerHostData>;
    /**
     * Verify that looker host is available
     */
    verifyHostConnection(): Promise<boolean>;
    /**
     * Update window title (if allowed)
     * @param title new window title
     */
    updateTitle(title: string): void;
    /**
     * Update location of current window (if allowed). Navigating to
     * a new host is NOT allowed
     * @param url - new url - should begin with '/'
     * @param state push state
     * @param target when set opens new browser window. Use
     *        openBrowserWindow instead.
     */
    updateLocation(url: string, state?: any, target?: string): void;
    /**
     * Open new browser window with URL
     * @param url for window
     * @param target name of window. Defaults to _blank
     */
    openBrowserWindow(url: string, target?: string): void;
    /**
     * Close currently opened popovers (menus for example)
     */
    closeHostPopovers(): void;
    /**
     * Store an item in local storage. Note that local storage is name
     * spaced to the extension. It is not necessary to include the extension
     * name in the name of the item.
     * @param name of item
     * @param value to store in local storage
     */
    localStorageSetItem(name: string, value?: string): Promise<boolean>;
    /**
     * Get an item from local storage. Note that local storage is name
     * spaced to the extension. It is not necessary to include the extension
     * name in the name of the item.
     * @param name of item
     */
    localStorageRemoveItem(name: string): Promise<boolean>;
    /**
     * Remove an item from local storage. Note that local storage is name
     * spaced to the extension. It is not necessary to include the extension
     * name in the name of the item.
     * @param name of item
     */
    localStorageGetItem(name: string): Promise<string | null>;
    /**
     * Track some kind of action.
     * @param name of action
     * @param trackAction of action
     * @param attributes associated with action
     */
    track(name: string, trackAction: string, attributes?: Record<string, any>): void;
    /**
     * Error event details. Report error details to the Looker host
     * Notes:
     * 1. Because crossorigin is not set on the script tag that loads the extension
     *    details of the error cannot be determined.
     * 2. In development mode (at least if react is being used), an error will
     *    be recorded twice. This is because react reports the failure to get
     *    details of the error as an error.
     */
    error(errorEvent: ErrorEvent): void;
    /**
     * Notify host that client route has changed
     * @param route
     * @param routeState state of route
     */
    clientRouteChanged(route: string, routeState?: any): void;
    /**
     * External API proxy to the browser fetch API.
     * Do not attempt to call internal Looker APIs. Any attempt to do so will be rejected.
     * Protocol MUST be https.
     * Entitlements must be defined for the extension in the manifest application in order to use this feature.
     * At a minimum, the domain and top level domain must be specified in the entitlements.
     * @param resource url to call
     * @param init. object containing custom parameters
     * @param responseBodyType indicates how to handle the response body. If omitted an attempt will be made
     *                         to determine how to handle the response body based upon the content type of the
     *                         response. Ultimately it defaults to a text response.
     */
    fetchProxy(resource: string, init?: FetchCustomParameters, responseBodyType?: FetchResponseBodyType): Promise<any>;
}
