"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserTransport = exports.BrowserCryptoHash = void 0;
const readable_stream_1 = require("readable-stream");
const transport_1 = require("./transport");
const baseTransport_1 = require("./baseTransport");
const constants_1 = require("./constants");
async function parseResponse(res) {
    if (res.contentType.match(/application\/json/g)) {
        try {
            return JSON.parse(await res.body);
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    else if (res.contentType === 'text' ||
        res.contentType.startsWith('text/')) {
        return res.body.toString();
    }
    else {
        try {
            return res.body;
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
}
class BrowserCryptoHash {
    arrayToHex(array) {
        return Array.from(array)
            .map((b) => b.toString(16).padStart(2, '0'))
            .join('');
    }
    secureRandom(byteCount) {
        const bytes = new Uint8Array(byteCount);
        window.crypto.getRandomValues(bytes);
        return this.arrayToHex(bytes);
    }
    async sha256Hash(message) {
        const msgUint8 = new TextEncoder().encode(message);
        const hashBuffer = await window.crypto.subtle.digest('SHA-256', msgUint8);
        return this.arrayToHex(new Uint8Array(hashBuffer));
    }
}
exports.BrowserCryptoHash = BrowserCryptoHash;
class BrowserTransport extends baseTransport_1.BaseTransport {
    constructor(options) {
        super(options);
        this.options = options;
    }
    async rawRequest(method, path, queryParams, body, authenticator, options) {
        options = Object.assign(Object.assign({}, this.options), options);
        const requestPath = this.makeUrl(path, options, queryParams);
        const props = await this.initRequest(method, requestPath, body, authenticator, options);
        const req = fetch(props.url, props);
        const res = await req;
        const contentType = String(res.headers.get('content-type'));
        return {
            body: await res.text(),
            contentType,
            ok: true,
            statusCode: res.status,
            statusMessage: res.statusText,
        };
    }
    async request(method, path, queryParams, body, authenticator, options) {
        try {
            const res = await this.rawRequest(method, path, queryParams, body, authenticator, options);
            const parsed = await parseResponse(res);
            if (this.ok(res)) {
                return { ok: true, value: parsed };
            }
            else {
                return { error: parsed, ok: false };
            }
        }
        catch (e) {
            const error = {
                message: typeof e.message === 'string'
                    ? e.message
                    : `The SDK call was not successful. The error was '${e}'.`,
                type: 'sdk_error',
            };
            return { error, ok: false };
        }
    }
    async initRequest(method, path, body, authenticator, options) {
        const agentTag = (options === null || options === void 0 ? void 0 : options.agentTag) || `${transport_1.agentPrefix} ${constants_1.lookerVersion}`;
        options = options ? Object.assign(Object.assign({}, this.options), options) : this.options;
        const headers = { [transport_1.LookerAppId]: agentTag };
        if (options && options.headers) {
            Object.keys(options.headers).forEach((key) => {
                headers[key] = options.headers[key];
            });
        }
        let props = {
            body: body
                ? typeof body === 'string'
                    ? body
                    : JSON.stringify(body)
                : undefined,
            credentials: 'same-origin',
            headers: headers,
            method,
            url: path,
        };
        if (authenticator) {
            props = await authenticator(props);
        }
        return props;
    }
    async stream(callback, method, path, queryParams, body, authenticator, options) {
        options = options ? Object.assign(Object.assign({}, this.options), options) : this.options;
        const stream = new readable_stream_1.PassThrough();
        const returnPromise = callback(stream);
        const requestPath = this.makeUrl(path, options, queryParams);
        const props = await this.initRequest(method, requestPath, body, authenticator, options);
        transport_1.trace(`[stream] attempting to stream via download url`, props);
        return Promise.reject(Error(`Streaming for${returnPromise ? 'callback' : ''} ${props.method} ${props.requestPath} is not implemented`));
    }
}
exports.BrowserTransport = BrowserTransport;
//# sourceMappingURL=browserTransport.js.map