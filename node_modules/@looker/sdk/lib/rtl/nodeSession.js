"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeSession = void 0;
const transport_1 = require("./transport");
const authToken_1 = require("./authToken");
const nodeTransport_1 = require("./nodeTransport");
const apiSettings_1 = require("./apiSettings");
const authSession_1 = require("./authSession");
const constants_1 = require("./constants");
const nodeSettings_1 = require("./nodeSettings");
const strPost = 'POST';
const strDelete = 'DELETE';
class NodeSession extends authSession_1.AuthSession {
    constructor(settings, transport) {
        super(settings, transport || new nodeTransport_1.NodeTransport(settings));
        this.settings = settings;
        this.apiPath = '';
        this._authToken = new authToken_1.AuthToken();
        this._sudoToken = new authToken_1.AuthToken();
        this.apiPath = `/api/${constants_1.defaultApiVersion}`;
    }
    get activeToken() {
        if (this._sudoToken.access_token) {
            return this._sudoToken;
        }
        return this._authToken;
    }
    isAuthenticated() {
        const token = this.activeToken;
        if (!(token && token.access_token))
            return false;
        return token.isActive();
    }
    async authenticate(props) {
        const token = await this.getToken();
        if (token && token.access_token) {
            props.headers.Authorization = `Bearer ${token.access_token}`;
        }
        return props;
    }
    isSudo() {
        return !!this.sudoId && this._sudoToken.isActive();
    }
    async getToken() {
        if (!this.isAuthenticated()) {
            await this.login();
        }
        return this.activeToken;
    }
    reset() {
        this.sudoId = '';
        this._authToken.reset();
        this._sudoToken.reset();
    }
    async login(sudoId) {
        if (sudoId || sudoId !== this.sudoId || !this.isAuthenticated()) {
            if (sudoId) {
                await this._login(sudoId.toString());
            }
            else {
                await this._login();
            }
        }
        return this.activeToken;
    }
    async logout() {
        let result = false;
        if (this.isAuthenticated()) {
            result = await this._logout();
        }
        return result;
    }
    async sudoLogout() {
        let result = false;
        if (this.isSudo()) {
            result = await this.logout();
            this._sudoToken.reset();
        }
        return result;
    }
    async _login(newId) {
        await this.sudoLogout();
        if (newId !== this.sudoId) {
            this.sudoId = newId || '';
        }
        if (!this._authToken.isActive()) {
            this.reset();
            const section = this.settings.readConfig();
            const clientId = nodeSettings_1.getenv(apiSettings_1.strLookerClientId, section.client_id);
            const clientSecret = nodeSettings_1.getenv(apiSettings_1.strLookerClientSecret, section.client_secret);
            if (!clientId || !clientSecret) {
                throw transport_1.sdkError({
                    message: 'API credentials client_id and/or client_secret are not set',
                });
            }
            const body = transport_1.encodeParams({
                client_id: clientId,
                client_secret: clientSecret,
            });
            const token = await this.ok(this.transport.request(strPost, `${this.apiPath}/login`, undefined, body));
            this._authToken.setToken(token);
        }
        if (this.sudoId) {
            const token = this.activeToken;
            const promise = this.transport.request(strPost, encodeURI(`${this.apiPath}/login/${newId}`), null, null, (init) => {
                if (token.access_token) {
                    init.headers.Authorization = `Bearer ${token.access_token}`;
                }
                return init;
            }, this.settings);
            const accessToken = await this.ok(promise);
            this._sudoToken.setToken(accessToken);
        }
        return this.activeToken;
    }
    async _logout() {
        const token = this.activeToken;
        const promise = this.transport.request(strDelete, `${this.apiPath}/logout`, null, null, (init) => {
            if (token.access_token) {
                init.headers.Authorization = `Bearer ${token.access_token}`;
            }
            return init;
        }, this.settings);
        await this.ok(promise);
        if (this.sudoId) {
            this.sudoId = '';
            this._sudoToken.reset();
            if (!this._authToken.isActive()) {
                await this.login();
            }
        }
        else {
            this.reset();
        }
        return true;
    }
}
exports.NodeSession = NodeSession;
//# sourceMappingURL=nodeSession.js.map