"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuthSession = void 0;
const authSession_1 = require("./authSession");
const transport_1 = require("./transport");
const authToken_1 = require("./authToken");
class OAuthSession extends authSession_1.AuthSession {
    constructor(services) {
        super(services.settings, services.transport);
        this.activeToken = new authToken_1.AuthToken();
        this.crypto = services.crypto;
        const keys = [
            'client_id',
            'redirect_uri',
            'base_url',
            'looker_url',
        ];
        keys.forEach((key) => {
            const value = this.settings[key];
            if (!value) {
                throw transport_1.sdkError({
                    message: `Missing required configuration setting: '${key}'`,
                });
            }
        });
    }
    async authenticate(props) {
        const token = await this.getToken();
        if (token.access_token) {
            props.headers.Authorization = `Bearer ${token.access_token}`;
        }
        return props;
    }
    async requestToken(body) {
        const url = new URL(this.settings.base_url);
        url.pathname = '/api/token';
        const token = await this.ok(this.transport.request('POST', url.toString(), undefined, body));
        return this.activeToken.setToken(token);
    }
    async createAuthCodeRequestUrl(scope, state) {
        this.code_verifier = this.crypto.secureRandom(32);
        const code_challenge = await this.crypto.sha256Hash(this.code_verifier);
        const params = {
            client_id: this.settings.client_id,
            code_challenge: code_challenge,
            code_challenge_method: 'S256',
            redirect_uri: this.settings.redirect_uri,
            response_type: 'code',
            scope: scope,
            state: state,
        };
        const url = new URL(this.settings.looker_url);
        url.pathname = '/auth';
        url.search = new URLSearchParams(params).toString();
        return url.toString();
    }
    redeemAuthCodeBody(authCode, codeVerifier) {
        const verifier = codeVerifier || this.code_verifier || '';
        return {
            client_id: this.settings.client_id,
            code: authCode,
            code_verifier: verifier,
            grant_type: 'authorization_code',
            redirect_uri: this.settings.redirect_uri,
        };
    }
    async redeemAuthCode(authCode, codeVerifier) {
        return this.requestToken(this.redeemAuthCodeBody(authCode, codeVerifier));
    }
    async getToken() {
        if (!this.isAuthenticated()) {
            if (this.activeToken.refresh_token) {
                await this.requestToken({
                    client_id: this.settings.client_id,
                    grant_type: 'refresh_token',
                    redirect_uri: this.settings.redirect_uri,
                    refresh_token: this.activeToken.refresh_token,
                });
            }
        }
        return this.activeToken;
    }
    isAuthenticated() {
        return this.activeToken.isActive();
    }
    async logout() {
        if (this.activeToken.access_token) {
            await this.ok(this.transport.request('DELETE', `/api/logout`, undefined, undefined, (init) => {
                init.headers.Authorization = `Bearer ${this.activeToken.access_token}`;
                return init;
            }));
            this.activeToken = new authToken_1.AuthToken();
            return true;
        }
        return false;
    }
}
exports.OAuthSession = OAuthSession;
//# sourceMappingURL=oauthSession.js.map