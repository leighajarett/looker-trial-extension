"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeTransport = exports.NodeCryptoHash = void 0;
const crypto_1 = __importDefault(require("crypto"));
const request_1 = __importDefault(require("request"));
const request_promise_native_1 = __importDefault(require("request-promise-native"));
const readable_stream_1 = require("readable-stream");
const errors_1 = require("request-promise-native/errors");
const transport_1 = require("./transport");
const baseTransport_1 = require("./baseTransport");
class NodeCryptoHash {
    secureRandom(byteCount) {
        return crypto_1.default.randomBytes(byteCount).toString('hex');
    }
    async sha256Hash(message) {
        const hash = crypto_1.default.createHash('sha256');
        hash.update(message);
        return Promise.resolve(hash.digest('hex'));
    }
}
exports.NodeCryptoHash = NodeCryptoHash;
async function parseResponse(res) {
    const mode = transport_1.responseMode(res.contentType);
    const utf8 = 'utf8';
    let result = await res.body;
    if (mode === transport_1.ResponseMode.string) {
        if (res.contentType.match(/^application\/.*\bjson\b/g)) {
            try {
                if (result instanceof Buffer) {
                    result = result.toString(utf8);
                }
                if (result instanceof Object) {
                    return result;
                }
                return JSON.parse(result.toString());
            }
            catch (error) {
                return Promise.reject(error);
            }
        }
        if (result instanceof Buffer) {
            result = result.toString(utf8);
        }
        return result.toString();
    }
    else {
        try {
            return result.toString('binary');
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
}
class NodeTransport extends baseTransport_1.BaseTransport {
    constructor(options) {
        super(options);
        this.options = options;
    }
    async rawRequest(method, path, queryParams, body, authenticator, options) {
        const init = await this.initRequest(method, path, queryParams, body, authenticator, options);
        const req = request_promise_native_1.default(init).promise();
        try {
            const res = await req;
            const resTyped = res;
            return {
                body: await resTyped.body,
                contentType: String(resTyped.headers['content-type']),
                ok: true,
                statusCode: resTyped.statusCode,
                statusMessage: resTyped.statusMessage,
            };
        }
        catch (e) {
            const statusMessage = `${method} ${path}`;
            let statusCode = 404;
            let contentType = 'text';
            let body = '';
            if (e instanceof errors_1.StatusCodeError) {
                statusCode = e.statusCode;
                const text = e.message;
                const matches = /^\d+\s*-\s*({.*})/gim.exec(text);
                if (matches && matches.length > 1) {
                    const json = matches[1];
                    const obj = JSON.parse(json);
                    body = Buffer.from(obj.data).toString('utf8');
                }
                else {
                    body = e.message;
                }
                body = `${statusMessage} ${body}`;
            }
            else if (e.error instanceof Buffer) {
                body = Buffer.from(e.error).toString('utf8');
            }
            else {
                body = JSON.stringify(e);
                contentType = 'application/json';
            }
            return {
                body,
                contentType,
                ok: false,
                statusCode,
                statusMessage,
            };
        }
    }
    async request(method, path, queryParams, body, authenticator, options) {
        try {
            const res = await this.rawRequest(method, path, queryParams, body, authenticator, options);
            const parsed = await parseResponse(res);
            if (this.ok(res)) {
                return { ok: true, value: parsed };
            }
            else {
                return { error: parsed, ok: false };
            }
        }
        catch (e) {
            const error = {
                message: typeof e.message === 'string'
                    ? e.message
                    : `The SDK call was not successful. The error was '${e}'.`,
                type: 'sdk_error',
            };
            return { error, ok: false };
        }
    }
    requestor(props) {
        const method = props.method.toString().toUpperCase();
        switch (method) {
            case 'GET':
                return request_1.default.get(props);
            case 'PUT':
                return request_1.default.put(props);
            case 'POST':
                return request_1.default.post(props);
            case 'PATCH':
                return request_1.default.patch(props);
            case 'DELETE':
                return request_1.default.put(props);
            case 'HEAD':
                return request_1.default.head(props);
            default:
                return request_1.default.get(props);
        }
    }
    async stream(callback, method, path, queryParams, body, authenticator, options) {
        const stream = new readable_stream_1.PassThrough();
        const returnPromise = callback(stream);
        const init = await this.initRequest(method, path, queryParams, body, authenticator, options);
        const streamPromise = new Promise((resolve, reject) => {
            transport_1.trace(`[stream] beginning stream via download url`, init);
            let hasResolved = false;
            const req = this.requestor(init);
            req
                .on('error', (err) => {
                if (hasResolved && err.code === 'ECONNRESET') {
                    transport_1.trace('ignoring ECONNRESET that occurred after streaming finished', init);
                }
                else {
                    transport_1.trace('streaming error', err);
                    reject(err);
                }
            })
                .on('finish', () => {
                transport_1.trace(`[stream] streaming via download url finished`, init);
            })
                .on('socket', (socket) => {
                transport_1.trace(`[stream] setting keepalive on socket`, init);
                socket.setKeepAlive(true);
            })
                .on('abort', () => {
                transport_1.trace(`[stream] streaming via download url aborted`, init);
            })
                .on('response', () => {
                transport_1.trace(`[stream] got response from download url`, init);
            })
                .on('close', () => {
                transport_1.trace(`[stream] request stream closed`, init);
            })
                .pipe(stream)
                .on('error', (err) => {
                transport_1.trace(`[stream] PassThrough stream error`, err);
                reject(err);
            })
                .on('finish', () => {
                transport_1.trace(`[stream] PassThrough stream finished`, init);
                resolve();
                hasResolved = true;
            })
                .on('close', () => {
                transport_1.trace(`[stream] PassThrough stream closed`, init);
            });
        });
        const results = await Promise.all([returnPromise, streamPromise]);
        return results[0];
    }
    verifySsl(options) {
        if (!options)
            options = this.options;
        return 'verify_ssl' in options ? options.verify_ssl : true;
    }
    timeout(options) {
        if (!options)
            options = this.options;
        if ('timeout' in options && options.timeout)
            return options.timeout;
        return transport_1.defaultTimeout;
    }
    async initRequest(method, path, queryParams, body, authenticator, options) {
        options = options ? Object.assign(Object.assign({}, this.options), options) : this.options;
        const headers = Object.assign({ [transport_1.LookerAppId]: options.agentTag }, options.headers);
        const requestPath = this.makeUrl(path, options, queryParams);
        let init = {
            body: body || undefined,
            encoding: null,
            headers: headers,
            json: body && typeof body !== 'string',
            method,
            rejectUnauthorized: this.verifySsl(options),
            resolveWithFullResponse: true,
            timeout: this.timeout(options) * 1000,
            url: requestPath,
        };
        if ('encoding' in options)
            init.encoding = options.encoding;
        if (authenticator) {
            init = await authenticator(init);
        }
        return init;
    }
}
exports.NodeTransport = NodeTransport;
//# sourceMappingURL=nodeTransport.js.map