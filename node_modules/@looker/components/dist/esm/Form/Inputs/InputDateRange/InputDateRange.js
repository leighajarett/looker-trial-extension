import React, { useState, useEffect } from 'react';
import styled from 'styled-components';
import isFunction from 'lodash/isFunction';
import partial from 'lodash/partial';
import min from 'lodash/min';
import max from 'lodash/max';
import isEqual from 'lodash/isEqual';
import values from 'lodash/values';
import { border, color, space, } from '@looker/design-tokens';
import { InputText, inputTextDefaults, inputTextHover, inputTextFocus, inputTextValidation, } from '../InputText';
import { Calendar } from '../../../Calendar';
import { Locales, formatDateString, parseDateFromString, useID, useReadOnlyWarn, } from '../../../utils';
const transformMonth = (date = new Date(Date.now()), monthDiff) => {
    const newDate = new Date(date);
    newDate.setDate(1);
    newDate.setMonth(newDate.getMonth() + monthDiff);
    return newDate;
};
const chooseDateToSet = (activeDateInput, newDate, dateRange = {}) => {
    const { from, to } = dateRange;
    if (newDate) {
        if (from && newDate < from) {
            return 'from';
        }
        else if (to && newDate > to) {
            return 'to';
        }
    }
    return activeDateInput;
};
const isDateRangeInView = (dateRange, viewMonth) => {
    if (!dateRange.from || !dateRange.to) {
        return false;
    }
    const monthOneTimestamp = viewMonth.getTime();
    const monthTwoTimestamp = transformMonth(viewMonth, 2).getTime();
    const fromTimestamp = dateRange.from.getTime();
    const toTimestamp = dateRange.to.getTime();
    if (fromTimestamp < monthOneTimestamp || toTimestamp >= monthTwoTimestamp) {
        return false;
    }
    return true;
};
export const InputDateRange = ({ defaultValue = {}, locale = Locales.English, onChange, onValidationFail, validationType, value, }) => {
    useReadOnlyWarn('InputDateRange', value, onChange);
    const [dateRange, setDateRange] = useState(value || defaultValue);
    const [activeDateInput, setActiveDateInput] = useState('from');
    const [viewMonth, setViewMonth] = useState(value && value.from
        ? value.from
        : defaultValue && defaultValue.from
            ? defaultValue.from
            : new Date(Date.now()));
    const viewNextMonth = new Date(viewMonth);
    viewNextMonth.setMonth(viewNextMonth.getMonth() + 1);
    const [fromTextInputValue, setFromTextInputValue] = useState(formatDateString(dateRange.from, locale));
    const [validFromDate, setValidFromDate] = useState(validationType !== 'error');
    const fromID = useID();
    const [toTextInputValue, setToTextInputValue] = useState(formatDateString(dateRange.to, locale));
    const [validToDate, setValidToDate] = useState(validationType !== 'error');
    const toID = useID();
    const inputs = {
        from: {
            isValid: validFromDate,
            setIsValid: setValidFromDate,
            setValue: setFromTextInputValue,
            value: fromTextInputValue,
        },
        to: {
            isValid: validToDate,
            setIsValid: setValidToDate,
            setValue: setToTextInputValue,
            value: toTextInputValue,
        },
    };
    useEffect(() => {
        if (value && !isEqual(value, dateRange)) {
            setDateRange(value);
            value.from && inputs.from.setValue(formatDateString(value.from, locale));
            value.to && inputs.to.setValue(formatDateString(value.to, locale));
            value.from &&
                !isDateRangeInView(value, viewMonth) &&
                setViewMonth(value.from);
        }
    }, [inputs.from, inputs.to, value, onChange]);
    const toggleActiveDateInput = () => {
        if (activeDateInput === 'from') {
            setActiveDateInput('to');
        }
        else {
            setActiveDateInput('from');
        }
    };
    const handleDateChange = (dateToSet, date) => {
        const newDateRange = Object.assign(Object.assign({}, dateRange), { [dateToSet]: date });
        if (activeDateInput === 'from') {
            newDateRange.to = max(values(newDateRange));
            newDateRange.from = min(values(newDateRange));
        }
        else {
            newDateRange.from = min(values(newDateRange));
            newDateRange.to = max(values(newDateRange));
        }
        const nonActiveInput = dateToSet === 'from' ? 'to' : 'from';
        inputs[nonActiveInput].setValue(formatDateString(newDateRange[nonActiveInput], locale));
        inputs.from.isValid || inputs.from.setIsValid(true);
        inputs.to.isValid || inputs.to.setIsValid(true);
        setDateRange(newDateRange);
        if (isFunction(onChange)) {
            onChange(newDateRange);
        }
    };
    const handleCalendarClick = (date) => {
        const dateToSet = chooseDateToSet(activeDateInput, date, dateRange);
        inputs[dateToSet].setValue(formatDateString(date, locale));
        handleDateChange(dateToSet, date);
        if (dateToSet === activeDateInput) {
            toggleActiveDateInput();
        }
    };
    const handleTextInputChange = (e) => {
        const value = e.target.value;
        inputs[activeDateInput].setValue(value);
        if (value.length === 0) {
            handleDateChange(activeDateInput);
        }
        else {
            const parsedValue = parseDateFromString(value, locale);
            if (parsedValue) {
                const newMonthFocus = activeDateInput === 'to'
                    ? transformMonth(parsedValue, -1)
                    : parsedValue;
                setViewMonth(newMonthFocus);
                handleDateChange(activeDateInput, parsedValue);
            }
        }
    };
    const handleValidation = (e) => {
        const value = e.target.value;
        const isValid = value.length === 0 || !!parseDateFromString(value, locale);
        inputs[activeDateInput].setIsValid(isValid);
        if (!isValid && isFunction(onValidationFail)) {
            onValidationFail(value);
        }
    };
    const handleNextClick = () => {
        setViewMonth(transformMonth(viewMonth, 1));
    };
    const handlePrevClick = () => {
        setViewMonth(transformMonth(viewMonth, -1));
    };
    const handleNowClick = () => {
        setViewMonth(new Date(Date.now()));
    };
    const handleTextInputFocus = (label) => setActiveDateInput(label);
    const handleMonthChange = (viewMonthDiff, month) => {
        setViewMonth(transformMonth(month, viewMonthDiff));
    };
    return (React.createElement(InputDateRangeWrapper, null,
        React.createElement(MultiCalendarLayout, { px: "small" },
            React.createElement(InputTextWrapper, { active: activeDateInput === 'from', validationType: inputs.from.isValid ? undefined : 'error' },
                React.createElement(InputLabel, { active: activeDateInput === 'from', htmlFor: fromID }, "From:"),
                React.createElement(InputText, { placeholder: `Date (${formatDateString(new Date(Date.now()), locale)})`, value: inputs.from.value, onChange: handleTextInputChange, onBlur: handleValidation, "data-testid": "date-from-text-input", id: fromID, onFocus: partial(handleTextInputFocus, 'from') })),
            React.createElement(InputTextWrapper, { active: activeDateInput === 'to', validationType: inputs.to.isValid ? undefined : 'error' },
                React.createElement(InputLabel, { active: activeDateInput === 'to', htmlFor: toID }, "To:"),
                React.createElement(InputText, { placeholder: `Date (${formatDateString(new Date(Date.now()), locale)})`, value: inputs.to.value, onChange: handleTextInputChange, onBlur: handleValidation, "data-testid": "date-to-text-input", id: toID, onFocus: partial(handleTextInputFocus, 'to') }))),
        React.createElement(MultiCalendarLayout, null,
            React.createElement(CalendarWrapper, null,
                React.createElement(Calendar, { selectedDates: dateRange, onDayClick: handleCalendarClick, locale: locale, viewMonth: viewMonth, onNowClick: handleNowClick, onPrevClick: handlePrevClick, showNextButton: false, onMonthChange: partial(handleMonthChange, 0) })),
            React.createElement(CalendarWrapper, null,
                React.createElement(Calendar, { selectedDates: dateRange, onDayClick: handleCalendarClick, locale: locale, viewMonth: viewNextMonth, onNowClick: handleNowClick, onNextClick: handleNextClick, showPreviousButton: false, onMonthChange: partial(handleMonthChange, -1) })))));
};
const InputLabel = styled.label.withConfig({ displayName: "InputLabel", componentId: "sc-139v7is" }) `
  color: ${({ theme: { colors }, active }) => active
    ? colors.semanticColors.primary.main
    : colors.semanticColors.neutral.main};
  font-weight: bold;
  text-transform: uppercase;
  font-size: ${({ theme }) => theme.fontSizes.xsmall};
  border-top-left-radius: ${({ theme }) => theme.radii.medium};
  border-bottom-left-radius: ${({ theme }) => theme.radii.medium};
  padding: 0.5rem;
`;
const InputDateRangeWrapper = styled.div.withConfig({ displayName: "InputDateRangeWrapper", componentId: "sc-945wn2" }) `
  display: inline-block;
`;
const MultiCalendarLayout = styled.div.withConfig({ displayName: "MultiCalendarLayout", componentId: "sc-10486gi" }) `
  ${space}
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-column-gap: ${({ theme }) => theme.space.large};
`;
const InputTextWrapper = styled.div.withConfig({ displayName: "InputTextWrapper", componentId: "sc-9b37ns" }) `
  ${border}
  ${color}

  display: grid;
  grid-template-columns: auto 1fr;
  align-items: center;
  margin-bottom: 1rem;

  &:hover {
    ${inputTextHover}
  }

  &:focus-within {
    ${inputTextFocus}
  }

  ${inputTextValidation}

  ${InputText} {
    border: none;
    border-radius: 0;
    padding: 0;
    margin: 0;
    box-shadow: none;
    background: transparent;
  }
`;
InputTextWrapper.defaultProps = Object.assign({}, inputTextDefaults);
const CalendarWrapper = styled.div.withConfig({ displayName: "CalendarWrapper", componentId: "sc-v58xsf" }) `
  ${Calendar} {
    padding: 0;
  }
`;
//# sourceMappingURL=InputDateRange.js.map