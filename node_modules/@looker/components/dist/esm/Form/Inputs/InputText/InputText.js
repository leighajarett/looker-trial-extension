var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import pick from 'lodash/pick';
import omit from 'lodash/omit';
import { border, typography, layout, pseudoClasses, space, reset, color, } from '@looker/design-tokens';
import React, { forwardRef, useRef } from 'react';
import styled, { css } from 'styled-components';
import { inputPropKeys } from '../InputProps';
import { Flex } from '../../../Layout';
import { Icon } from '../../../Icon/Icon';
import { Text } from '../../../Text/Text';
import { useForkedRef } from '../../../utils';
const InputComponent = forwardRef((_a, forwardedRef) => {
    var { className, iconAfter, iconBefore, prefix, suffix, type = 'text', validationType } = _a, props = __rest(_a, ["className", "iconAfter", "iconBefore", "prefix", "suffix", "type", "validationType"]);
    if (iconBefore && prefix) {
        console.warn(`Only use IconBefore or prefix not both at the same time. `);
        return null;
    }
    if (iconAfter && suffix) {
        console.warn(`Only use IconAfter or suffix not both at the same time. `);
        return null;
    }
    const internalRef = useRef(null);
    const ref = useForkedRef(internalRef, forwardedRef);
    const focusInput = () => internalRef.current && internalRef.current.focus();
    const before = iconBefore ? (React.createElement(InputIconStyle, { paddingRight: "xsmall" },
        React.createElement(Icon, { name: iconBefore, size: 20 }))) : prefix ? (React.createElement(InputIconStyle, { paddingRight: "xsmall" },
        React.createElement(Text, { fontSize: "small" }, prefix))) : null;
    const after = iconAfter ? (React.createElement(InputIconStyle, { paddingLeft: "xsmall" },
        React.createElement(Icon, { name: iconAfter, size: 20 }))) : suffix ? (React.createElement(InputIconStyle, { paddingLeft: "xsmall" },
        React.createElement(Text, { fontSize: "small" }, suffix))) : null;
    const inputProps = pick(omit(props, 'color', 'height', 'width'), inputPropKeys);
    return (React.createElement(InputLayout, { className: className, onClick: focusInput },
        before && before,
        React.createElement("input", Object.assign({}, inputProps, { "aria-invalid": validationType === 'error' ? 'true' : undefined, type: type, ref: ref })),
        after && after,
        validationType && (React.createElement(InputIconStyle, { paddingLeft: "xsmall" },
            React.createElement(Icon, { color: "palette.red500", name: "Warning", size: 18 })))));
});
export const inputTextHover = css `
  border-color: ${(props) => props.theme.colors.palette.charcoal300};
`;
export const inputTextFocus = css `
  border-color: ${(props) => props.theme.colors.palette.purple300};
  box-shadow: 0 0 0 2px ${(props) => props.theme.colors.palette.purple100};
  outline: none;
`;
export const inputTextDisabled = css `
  background: ${(props) => props.theme.colors.palette.charcoal100};
  color: ${(props) => props.theme.colors.palette.charcoal400};
  &:hover {
    border-color: ${(props) => props.theme.colors.palette.charcoal200};
  }
`;
export const inputHeight = '36px';
export const InputLayout = styled.div.withConfig({ displayName: "InputLayout", componentId: "sc-pkti6j" }) `
  align-items: center;
  background-color: ${(props) => props.theme.colors.palette.white};
  display: inline-flex;
  height: ${inputHeight};
  justify-content: space-evenly;

  input {
    border: none;
    background: transparent;
    flex: 1;
    font-size: ${(props) => props.theme.fontSizes.small};
    height: 100%;
    width: 100%;
    outline: none;
    padding: 0;
  }

  ::placeholder {
    color: ${(props) => props.theme.colors.palette.charcoal400};
  }

  &:hover {
    ${inputTextHover}
  }
  &:focus,
  :focus-within {
    ${inputTextFocus}
  }
`;
export const InputIconStyle = styled(Flex).withConfig({ displayName: "InputIconStyle", componentId: "sc-nei863" }) `
  color: ${(props) => props.theme.colors.palette.charcoal400};
  pointer-events: none;
`;
export const inputTextValidation = css `
  ${(props) => props.validationType === 'error'
    ? `
      border-color: ${props.theme.colors.palette.red400};
      &:hover {
        border-color: ${props.theme.colors.palette.red500};
      }
      &:focus,
      :focus-within {
        border-color: ${props.theme.colors.palette.red500};
        box-shadow: 0 0 0 2px ${props.theme.colors.palette.red100};
      }
      `
    : ''}
`;
export const InputText = styled(InputComponent).attrs((props) => {
    const padding = {
        px: props.px || props.p || 'small',
        py: props.py || props.p || 'none',
    };
    if (props.prefix || props.iconBefore) {
        padding.pl = 'xsmall';
    }
    if (props.suffix || props.iconAfter) {
        padding.pr = 'xsmall';
    }
    return padding;
}).withConfig({ displayName: "InputText", componentId: "sc-1htqid7" }) `
  ${reset}
  ${border}
  ${color}
  ${layout}
  ${space}
  ${typography}
  ${pseudoClasses}

  color: ${(props) => props.theme.colors.palette.charcoal700};

  ${(props) => (props.disabled ? inputTextDisabled : '')}

  ${inputTextValidation}
`;
export const inputTextDefaults = {
    border: 'solid 1px',
    borderColor: 'palette.charcoal200',
    borderRadius: 'medium',
    fontSize: 'small',
    height: '36px',
    width: '100%',
};
InputText.defaultProps = Object.assign(Object.assign({}, inputTextDefaults), { type: 'text' });
InputComponent.displayName = 'InputComponent';
//# sourceMappingURL=InputText.js.map