import React, { useState, useEffect, } from 'react';
import styled from 'styled-components';
import reduce from 'lodash/reduce';
import map from 'lodash/map';
import isFunction from 'lodash/isFunction';
import find from 'lodash/find';
import trim from 'lodash/trim';
import last from 'lodash/last';
import head from 'lodash/head';
import sortedIndex from 'lodash/sortedIndex';
import { Combobox, ComboboxInput, ComboboxList, ComboboxOption, } from '../Combobox';
import { useReadOnlyWarn } from '../../../utils';
import { formatTimeString, parseBase10Int, isValidTime, } from '../utils';
const cycleHourDisplay = (format, hour) => {
    if (format === '12h') {
        if (hour === 0) {
            return 12;
        }
        else if (hour > 12) {
            return hour - 12;
        }
    }
    return hour;
};
const formatLabel = (format, hour, minute) => {
    const formattedHour = formatTimeString(cycleHourDisplay(format, hour));
    const formattedMinute = formatTimeString(minute);
    const period = format === '12h' && (hour < 12 ? 'am' : 'pm');
    return trim(`${formattedHour}:${formattedMinute} ${period || ''}`);
};
const generateMinuteIntervals = (interval) => {
    const minutes = new Array(60 / interval);
    return map(minutes, (_, index) => formatTimeString(index * interval));
};
const generateTimes = (format, interval) => {
    const hours = new Array(24);
    const minutes = generateMinuteIntervals(interval);
    return reduce(hours, (result, _, hour) => {
        const formatLabel = format === '12h' && (hour < 12 ? 'am' : 'pm');
        const formattedHour = formatTimeString(cycleHourDisplay(format, hour));
        const hourWithMinutes = map(minutes, (minute) => {
            const label = trim(`${formattedHour}:${minute} ${formatLabel || ''}`);
            const value = `${formatTimeString(hour)}:${minute}`;
            return {
                label,
                value,
            };
        });
        return [...result, ...hourWithMinutes];
    }, []);
};
const matchClosestMinute = (interval, timeCode) => {
    const minuteOptions = map(generateMinuteIntervals(interval), parseBase10Int);
    const now = new Date(Date.now());
    const currentMinute = timeCode
        ? parseBase10Int(timeCode.split(':')[1])
        : now.getMinutes();
    const currentHour = timeCode
        ? parseBase10Int(timeCode.split(':')[0])
        : now.getHours();
    const index = sortedIndex(minuteOptions, currentMinute);
    const optionBefore = minuteOptions[index - 1] || head(minuteOptions);
    const optionAfter = minuteOptions[index] || last(minuteOptions);
    const roundedMinute = currentMinute - optionBefore < optionAfter - currentMinute
        ? optionBefore
        : optionAfter;
    const formattedHour = formatTimeString(currentHour);
    const formattedMinute = formatTimeString(roundedMinute);
    return `${formattedHour}:${formattedMinute}`;
};
const createOptionFromStringValue = (format, value) => {
    const [hour, minute] = map(value.split(':'), parseBase10Int);
    return {
        label: formatLabel(format, hour, minute),
        value,
    };
};
const createOptionFromLabel = (format, label) => {
    const period = label.toLowerCase().includes('p') ? 'pm' : 'am';
    const numericTime = label.replace(/[apm]/gi, '');
    const [hour = 0, minute = 0] = numericTime.split(':').map(parseBase10Int);
    const hr24 = hour + (period === 'pm' ? 12 : 0);
    const value = `${formatTimeString(hr24)}:${formatTimeString(minute)}`;
    if (isValidTime(value)) {
        return { label: formatLabel(format, hr24, minute), value };
    }
    return undefined;
};
const matchStringValueToOption = (options, format, value) => {
    if (value && isValidTime(value)) {
        const option = find(options, { value: value });
        return option || createOptionFromStringValue(format, value);
    }
    return undefined;
};
const matchStringLabelToOption = (options, label) => {
    if (label) {
        return find(options, (o) => {
            return o.label ? o.label.includes(label) : false;
        });
    }
    return undefined;
};
const setScrollIntoView = (options, interval, selectedOption) => {
    if (selectedOption) {
        return map(options, (option) => matchClosestMinute(interval, selectedOption.value) === option.value
            ? Object.assign(Object.assign({}, option), { scrollIntoView: true }) : option);
    }
    const now = matchClosestMinute(interval);
    return map(options, (option) => option.value === now ? Object.assign(Object.assign({}, option), { scrollIntoView: true }) : option);
};
export const InputTimeSelect = ({ interval = 15, format = '12h', onChange, value = '', defaultValue, }) => {
    useReadOnlyWarn('InputTimeSelect', value, onChange);
    const valueProp = value || defaultValue;
    if (!isValidTime(valueProp)) {
        console.error(`Invalid time ("${valueProp}") passed to <InputTimeSelect />. Value should be formatted as a 24-hour string (e.g. value="02:00" or value="23:15").`);
    }
    const timeOptions = generateTimes(format, interval);
    const [selectedOption, setSelectedOption] = useState();
    const [inputTextValue, setInputTextValue] = useState('');
    useEffect(() => {
        setSelectedOption(matchStringValueToOption(timeOptions, format, value || defaultValue));
    }, [value]);
    const handleChange = (newSelectedOption) => {
        setSelectedOption(newSelectedOption);
        const newValue = newSelectedOption ? newSelectedOption.value : undefined;
        if (isFunction(onChange) && isValidTime(newValue)) {
            onChange(newValue);
        }
    };
    const handleTextInputChange = (e) => {
        setInputTextValue(e.target.value);
    };
    const handleTextInputBlur = () => {
        setInputTextValue('');
    };
    const handleKeyDown = (e) => {
        if (e.key === 'Enter') {
            if (inputTextValue.length) {
                const option = createOptionFromLabel(format, inputTextValue);
                handleChange(option);
            }
        }
    };
    const optionToFocus = matchStringLabelToOption(timeOptions, inputTextValue) || selectedOption;
    const timeOptionsFocused = setScrollIntoView(timeOptions, interval, optionToFocus);
    return (React.createElement(InputTimeSelectWrapper, null,
        React.createElement(Combobox, { value: selectedOption, onChange: handleChange },
            React.createElement(ComboboxInput, { placeholder: "Select time", onChange: handleTextInputChange, onBlur: handleTextInputBlur, onKeyDown: handleKeyDown, autoComplete: false }),
            React.createElement(ComboboxList, { persistSelection: true }, timeOptionsFocused.map((option, index) => (React.createElement(ComboboxOption, Object.assign({}, option, { key: index }))))))));
};
const InputTimeSelectWrapper = styled.div.withConfig({ displayName: "InputTimeSelectWrapper", componentId: "sc-1v9yb70" }) `
  display: inline-block;
`;
//# sourceMappingURL=InputTimeSelect.js.map