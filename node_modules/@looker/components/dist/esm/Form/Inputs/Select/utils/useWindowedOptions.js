import findIndex from 'lodash/findIndex';
import React, { useContext, useEffect, useMemo, useRef } from 'react';
import { getWindowedListBoundaries } from '../../../../utils/getWindowedListBoundaries';
import { ComboboxContext, ComboboxMultiContext } from '../../Combobox';
export const optionHeight = 28;
export function useShouldWindowOptions(options, propsWindowedOptions) {
    return useMemo(() => {
        if (!options)
            return false;
        if (propsWindowedOptions === false)
            return false;
        if (options.length < 100 && !propsWindowedOptions)
            return false;
        const groupedOptions = options.find((option) => option.options !== undefined);
        if (groupedOptions) {
            if (propsWindowedOptions) {
                console.warn('The `windowedOptions` prop does not support grouped options.');
            }
            return false;
        }
        return true;
    }, [options, propsWindowedOptions]);
}
export function useWindowedOptions(windowedOptions, options, isMulti) {
    const context = useContext(ComboboxContext);
    const contextMulti = useContext(ComboboxMultiContext);
    const contextToUse = isMulti ? contextMulti : context;
    const { data: { navigationOption }, listClientRect, listScrollPosition, optionsRef, } = contextToUse;
    const flatOptions = options;
    useEffect(() => {
        if (windowedOptions &&
            flatOptions &&
            flatOptions.length > 0 &&
            optionsRef) {
            optionsRef.current = [...flatOptions];
        }
    }, [flatOptions, optionsRef, windowedOptions]);
    const containerHeight = listClientRect && listClientRect.height;
    let { start, end } = useMemo(() => getWindowedListBoundaries({
        containerHeight,
        containerScrollPosition: listScrollPosition,
        enabled: windowedOptions,
        itemHeight: optionHeight,
        length: flatOptions ? flatOptions.length : 0,
    }), [flatOptions, containerHeight, listScrollPosition, windowedOptions]);
    const isFirstRender = useRef(true);
    if (windowedOptions && isFirstRender.current) {
        if (navigationOption) {
            const selectedIndex = findIndex(options, [
                'value',
                navigationOption.value,
            ]);
            start = selectedIndex;
            end = selectedIndex;
        }
        isFirstRender.current = false;
    }
    let scrollToFirst = false;
    let scrollToLast = false;
    if (windowedOptions &&
        flatOptions &&
        flatOptions.length &&
        navigationOption) {
        scrollToFirst = start > 0 && navigationOption.value === flatOptions[0].value;
        scrollToLast =
            end < flatOptions.length - 1 &&
                navigationOption.value === flatOptions[flatOptions.length - 1].value;
    }
    const afterLength = flatOptions ? flatOptions.length - 1 - end : 0;
    return {
        after: afterLength > 0 ? (React.createElement("li", { style: { height: `${afterLength * optionHeight}px` } })) : null,
        before: start > 0 ? React.createElement("li", { style: { height: `${start * optionHeight}px` } }) : null,
        end,
        scrollToFirst,
        scrollToLast,
        start,
    };
}
//# sourceMappingURL=useWindowedOptions.js.map