import React, { useReducer, useEffect, useRef, } from 'react';
import styled from 'styled-components';
import noop from 'lodash/noop';
import add from 'lodash/add';
import subtract from 'lodash/subtract';
import some from 'lodash/some';
import { border, space, reset, } from '@looker/design-tokens';
import { InputText, inputTextDefaults, inputTextHover, inputTextFocus, inputTextDisabled, inputTextValidation, } from '../InputText';
import { formatTimeString, parseBase10Int, isValidTime, } from '../utils';
const initialState = {
    charCount: 0,
    format: '12h',
    hour: '',
    isComplete: false,
    minute: '',
    period: '',
    subInputFocus: 'NONE',
};
const isNumericKey = (e) => (e.keyCode >= 48 && e.keyCode <= 57) || (e.keyCode >= 96 && e.keyCode <= 105);
const isArrowKey = (e) => e.key === 'ArrowUp' || e.key === 'ArrowDown';
const isDeleteKey = (e) => {
    return e.key === 'Backspace' || e.key === 'Delete';
};
const selectNextInput = (current) => {
    switch (current) {
        case 'HOUR':
            return 'MINUTE';
        case 'MINUTE':
            return 'PERIOD';
        case 'PERIOD':
            return 'NONE';
        default:
            return 'NONE';
    }
};
const isInputComplete = ({ format, hour, minute, period, }) => {
    if (format === '12h') {
        return !!(hour.length && minute.length && period.length);
    }
    return !!(hour.length && minute.length);
};
const reducer = (state, action) => {
    const { payload, type } = action;
    const inputValues = {
        format: state.format,
        hour: state.hour,
        minute: state.minute,
        period: state.period,
    };
    switch (type) {
        case 'SET_FOCUS':
            return Object.assign(Object.assign({}, state), { subInputFocus: payload });
        case 'FOCUS_NEXT_FIELD':
            return Object.assign(Object.assign({}, state), { subInputFocus: selectNextInput(state.subInputFocus) });
        case 'INCREMENT_CHAR_COUNT':
            return Object.assign(Object.assign({}, state), { charCount: state.charCount + 1 });
        case 'RESET_CHAR_COUNT':
            return Object.assign(Object.assign({}, state), { charCount: 0 });
        case 'SET_HOUR_VALUE':
            return Object.assign(Object.assign({}, state), { hour: payload, isComplete: isInputComplete(Object.assign(Object.assign({}, inputValues), { hour: payload })) });
        case 'SET_MINUTE_VALUE':
            return Object.assign(Object.assign({}, state), { isComplete: isInputComplete(Object.assign(Object.assign({}, inputValues), { minute: payload })), minute: payload });
        case 'SET_PERIOD_VALUE':
            return Object.assign(Object.assign({}, state), { isComplete: isInputComplete(Object.assign(Object.assign({}, inputValues), { period: payload })), period: payload });
        default:
            return state;
    }
};
const cycleValue = (currentValue, key, max, min) => {
    const transform = key === 'ArrowUp' ? add : subtract;
    const newValue = transform(parseBase10Int(currentValue), 1);
    if (newValue < min) {
        return formatTimeString(max);
    }
    else if (newValue > max) {
        return formatTimeString(min);
    }
    else {
        return formatTimeString(newValue);
    }
};
const parseValue = (format, value = '') => {
    if (value.length) {
        const [hr24, minute] = value.split(':').map(parseBase10Int);
        const hr12 = hr24 <= 12 ? hr24 : hr24 - 12;
        const period = hr24 >= 12 ? 'PM' : 'AM';
        return [
            formatTimeString(format === '12h' ? hr12 : hr24),
            formatTimeString(minute),
            period,
        ];
    }
    return ['', '', ''];
};
export const convert12To24HrString = (value) => {
    const period = value.includes('P') ? 'PM' : 'AM';
    const numericTime = value.replace(/[APM]/gi, '');
    const [hour = 0, minute = 0] = numericTime.split(':').map(parseBase10Int);
    let hr24;
    if (period === 'AM' && hour === 12) {
        hr24 = 0;
    }
    else if (period === 'PM' && hour < 12) {
        hr24 = hour + 12;
    }
    else {
        hr24 = hour;
    }
    return `${formatTimeString(hr24)}:${formatTimeString(minute)}`;
};
const InternalInputTime = ({ format = '12h', onChange, defaultValue, value, className, disabled, readOnly, id, onFocus, onBlur, required, onValidationFail, }) => {
    const [inputState, dispatch] = useReducer(reducer, Object.assign(Object.assign({}, initialState), { format }));
    const { hour, minute, period, isComplete, subInputFocus } = inputState;
    const inputRefs = {
        HOUR: useRef(null),
        MINUTE: useRef(null),
        NONE: useRef(null),
        PERIOD: useRef(null),
    };
    const handleValidKeyDown = () => {
        dispatch({ type: 'INCREMENT_CHAR_COUNT' });
        if (inputState.charCount > 0) {
            dispatch({ type: 'FOCUS_NEXT_FIELD' });
        }
    };
    const handleDelete = (setStateCB) => {
        onChange && onChange(undefined);
        setStateCB();
    };
    const handleHourKeyDown = (e) => {
        const clearHourField = () => {
            dispatch({ payload: '', type: 'SET_HOUR_VALUE' });
            dispatch({ type: 'RESET_CHAR_COUNT' });
        };
        if (isNumericKey(e)) {
            const value = parseBase10Int(inputState.charCount === 1 ? `${hour}${e.key}` : e.key);
            if (value < 24) {
                if (format === '12h' && value > 12) {
                    dispatch({
                        payload: formatTimeString(value - 12),
                        type: 'SET_HOUR_VALUE',
                    });
                    dispatch({ payload: 'PM', type: 'SET_PERIOD_VALUE' });
                }
                else {
                    dispatch({
                        payload: formatTimeString(value),
                        type: 'SET_HOUR_VALUE',
                    });
                }
                handleValidKeyDown();
            }
            else {
                clearHourField();
            }
        }
        else if (isArrowKey(e)) {
            const max = format === '12h' ? 12 : 23;
            const min = format === '12h' ? 1 : 0;
            dispatch({
                payload: cycleValue(hour, e.key, max, min),
                type: 'SET_HOUR_VALUE',
            });
        }
        else if (isDeleteKey(e)) {
            handleDelete(clearHourField);
        }
    };
    const handleMinuteKeyDown = (e) => {
        const clearMinuteField = () => {
            dispatch({ payload: '', type: 'SET_MINUTE_VALUE' });
            dispatch({ type: 'RESET_CHAR_COUNT' });
        };
        if (isNumericKey(e)) {
            const value = parseBase10Int(inputState.charCount === 1 ? `${minute}${e.key}` : e.key);
            if (value < 60) {
                dispatch({
                    payload: formatTimeString(value),
                    type: 'SET_MINUTE_VALUE',
                });
                handleValidKeyDown();
            }
            else {
                clearMinuteField();
            }
        }
        else if (isArrowKey(e)) {
            dispatch({
                payload: cycleValue(minute, e.key, 59, 0),
                type: 'SET_MINUTE_VALUE',
            });
        }
        else if (isDeleteKey(e)) {
            handleDelete(clearMinuteField);
        }
    };
    const handlePeriodKeyDown = (e) => {
        const clearPeriodField = () => {
            dispatch({ payload: '', type: 'SET_PERIOD_VALUE' });
            dispatch({ type: 'RESET_CHAR_COUNT' });
        };
        const key = e.key.toUpperCase();
        if (key === 'P' || key === 'A') {
            dispatch({ payload: `${key}M`, type: 'SET_PERIOD_VALUE' });
            handleValidKeyDown();
        }
        else if (isArrowKey(e)) {
            const nextPeriod = period === 'PM' ? 'AM' : 'PM';
            dispatch({ payload: nextPeriod, type: 'SET_PERIOD_VALUE' });
        }
        else if (isDeleteKey(e)) {
            handleDelete(clearPeriodField);
        }
    };
    const handleHourFocus = () => dispatch({ payload: 'HOUR', type: 'SET_FOCUS' });
    const handleMinuteFocus = () => dispatch({ payload: 'MINUTE', type: 'SET_FOCUS' });
    const handlePeriodFocus = () => dispatch({ payload: 'PERIOD', type: 'SET_FOCUS' });
    const handleBlur = () => {
        dispatch({ payload: 'NONE', type: 'SET_FOCUS' });
        dispatch({ type: 'RESET_CHAR_COUNT' });
    };
    useEffect(() => {
        const ref = inputRefs[subInputFocus || ''];
        if (ref.current) {
            ref.current.focus();
        }
    }, [subInputFocus]);
    useEffect(() => {
        const valueProp = value || defaultValue;
        if (isValidTime(valueProp)) {
            const [newHour, newMinute, newPeriod] = parseValue(format, valueProp);
            hour !== newHour &&
                dispatch({ payload: newHour, type: 'SET_HOUR_VALUE' });
            minute !== newMinute &&
                dispatch({ payload: newMinute, type: 'SET_MINUTE_VALUE' });
            period !== newPeriod &&
                dispatch({ payload: newPeriod, type: 'SET_PERIOD_VALUE' });
        }
        else {
            onValidationFail && onValidationFail(valueProp);
            console.error(`Invalid time ("${valueProp}") passed to <InputTime />. Value should be formatted as a 24-hour string (e.g. value="02:00" or value="23:15").`);
        }
    }, [value]);
    useEffect(() => {
        if (isComplete) {
            const newValue = format === '12h'
                ? convert12To24HrString(`${hour}:${minute} ${period}`)
                : `${hour}:${minute}`;
            if (newValue !== value) {
                onChange && onChange(`${newValue}`);
            }
        }
    }, [isComplete, hour, minute, period]);
    const hasInputValues = some([hour, minute, period], 'length');
    return (React.createElement("div", { className: `${className} ${disabled && 'disabled'}`, onFocus: onFocus, onBlur: onBlur },
        React.createElement(InputTimeWrapper, { hasInputValues: hasInputValues },
            React.createElement(InputTimeLayout, null,
                React.createElement(InputText, { id: id, maxLength: 2, placeholder: "--", value: hour, onKeyDown: readOnly ? noop : handleHourKeyDown, onFocus: handleHourFocus, onBlur: handleBlur, onChange: noop, ref: inputRefs.HOUR, "data-testid": "input-hour", disabled: disabled, readOnly: readOnly, required: required }),
                React.createElement("div", null, ":"),
                React.createElement(InputText, { maxLength: 2, placeholder: "--", value: minute, onKeyDown: readOnly ? noop : handleMinuteKeyDown, onFocus: handleMinuteFocus, onBlur: handleBlur, onChange: noop, ref: inputRefs.MINUTE, "data-testid": "input-minute", disabled: disabled, readOnly: readOnly, required: required }),
                format === '12h' ? (React.createElement(InputText, { maxLength: 2, placeholder: "--", value: period, onKeyDown: readOnly ? noop : handlePeriodKeyDown, onFocus: handlePeriodFocus, onBlur: handleBlur, onChange: noop, ref: inputRefs.PERIOD, "data-testid": "input-period", disabled: disabled, readOnly: readOnly, required: required })) : (React.createElement("span", null))))));
};
export const InputTime = styled(InternalInputTime).withConfig({ displayName: "InputTime", componentId: "sc-vg3d36" }) `
  ${reset}
  ${border}
  ${space}
  display: inline-block;
  padding: ${({ theme }) => theme.space.xxsmall};
  background: ${({ theme }) => theme.colors.palette.white};
  &:focus-within {
    ${inputTextFocus}
  }
  &:hover {
    ${inputTextHover}
  }

  &.disabled {
    ${inputTextDisabled}
  }

  ${inputTextValidation}
`;
InputTime.defaultProps = Object.assign({}, inputTextDefaults);
const InputTimeWrapper = styled.div.withConfig({ displayName: "InputTimeWrapper", componentId: "sc-1veezv1" }) `
  color: ${({ theme, hasInputValues }) => hasInputValues
    ? theme.colors.palette.charcoal600
    : theme.colors.palette.charcoal300};

  ${InputText} {
    border: none;
    border-radius: 0;
    padding: 0;
    margin: 0;
    box-shadow: none;
    background: transparent;
    width: 1.75rem;
    height: auto;
    line-height: ${({ theme }) => theme.lineHeights.medium};
    text-align: center;
    color: inherit;
    &::placeholder {
      color: inherit;
    }
    &:focus {
      background: ${({ theme }) => theme.colors.palette.purple100};
    }
  }
`;
const InputTimeLayout = styled.div.withConfig({ displayName: "InputTimeLayout", componentId: "sc-1aj2rnq" }) `
  display: grid;
  grid-gap: 0.15rem;
  grid-template-columns: repeat(4, auto);
  align-items: center;
`;
//# sourceMappingURL=InputTime.js.map