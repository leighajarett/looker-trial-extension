var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { forwardRef, useRef, useContext, useCallback } from 'react';
import styled from 'styled-components';
import { useForkedRef, useWrapEvent } from '../../../utils';
import { Flex } from '../../../Layout';
import { InputChipsBase, } from '../InputChips';
import { InputSearchControls } from '../InputSearch';
import { ComboboxMultiContext } from './ComboboxContext';
import { comboboxStyles, comboboxPaddingRight, } from './ComboboxInput';
import { getComboboxText } from './utils/getComboboxText';
import { makeHash } from './utils/makeHash';
import { ComboboxActionType, ComboboxState } from './utils/state';
import { useInputEvents } from './utils/useInputEvents';
import { useInputPropRefs } from './utils/useInputPropRefs';
export const ComboboxMultiInputInternal = forwardRef((props, forwardedRef) => {
    const { autoComplete = true, readOnly = false, onClear, onInputChange, inputValue: controlledInputValue } = props, rest = __rest(props, ["autoComplete", "readOnly", "onClear", "onInputChange", "inputValue"]);
    const { data: { navigationOption, options, inputValue: contextInputValue }, onChange: contextOnChange, inputCallbackRef, state, transition, id, } = useContext(ComboboxMultiContext);
    useInputPropRefs(props, ComboboxMultiContext);
    function handleClear() {
        transition && transition(ComboboxActionType.CLEAR);
        contextOnChange && contextOnChange([]);
    }
    function handleChange(values) {
        transition &&
            transition(ComboboxActionType.CHANGE_VALUES, { inputValues: values });
        const newOptions = options.filter((option) => values.includes(getComboboxText(option)));
        contextOnChange && contextOnChange(newOptions);
    }
    const handleInputValueChange = useCallback((value) => {
        transition &&
            transition(ComboboxActionType.CHANGE, { inputValue: value });
    }, [transition]);
    const isInputting = useRef(false);
    if (controlledInputValue !== undefined &&
        contextInputValue &&
        controlledInputValue !== contextInputValue) {
        if (isInputting.current) {
            handleInputValueChange(controlledInputValue);
        }
        else {
            transition &&
                transition(ComboboxActionType.CHANGE_SILENT, {
                    inputValue: controlledInputValue,
                });
        }
    }
    const isControlled = controlledInputValue !== undefined;
    const handleInputChange = useCallback((value) => {
        isInputting.current = true;
        if (!isControlled) {
            handleInputValueChange(value);
        }
        requestAnimationFrame(() => {
            isInputting.current = false;
        });
    }, [handleInputValueChange, isControlled]);
    const inputValues = options.map((option) => getComboboxText(option));
    let inputValue = contextInputValue || '';
    if (autoComplete &&
        (state === ComboboxState.NAVIGATING ||
            state === ComboboxState.INTERACTING) &&
        navigationOption) {
        inputValue = getComboboxText(navigationOption);
    }
    const wrappedOnClear = useWrapEvent(handleClear, onClear);
    const wrappedOnInputChange = useCallback((value) => {
        handleInputChange(value);
        onInputChange && onInputChange(value);
    }, [handleInputChange, onInputChange]);
    const inputEvents = useInputEvents(props, ComboboxMultiContext);
    const ref = useForkedRef(inputCallbackRef, forwardedRef);
    return (React.createElement(InputChipsBase, Object.assign({}, rest, inputEvents, { ref: ref, readOnly: readOnly, values: inputValues, onChange: handleChange, onClear: wrappedOnClear, inputValue: inputValue, onInputChange: wrappedOnInputChange, id: `listbox-${id}`, autoComplete: "off", "aria-autocomplete": "both", "aria-activedescendant": navigationOption
            ? String(makeHash(navigationOption ? navigationOption.value : ''))
            : undefined })));
});
ComboboxMultiInputInternal.displayName = 'ComboboxMultiInputInternal';
export const ComboboxMultiInput = styled(ComboboxMultiInputInternal).withConfig({ displayName: "ComboboxMultiInput", componentId: "sc-bctbg9" }) `
  ${comboboxStyles}
  padding-right: 0;

  ${Flex} {
    padding-right: calc(${(props) => props.theme.space.xlarge} * 2);
  }

  ${InputSearchControls} {
    right: ${comboboxPaddingRight};
  }
`;
ComboboxMultiInput.defaultProps = {
    width: '100%',
};
//# sourceMappingURL=ComboboxMultiInput.js.map