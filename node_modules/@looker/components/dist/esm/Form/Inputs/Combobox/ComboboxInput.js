var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import btoa from 'btoa';
import React, { forwardRef, useRef, useContext } from 'react';
import styled, { css } from 'styled-components';
import { useForkedRef, useWrapEvent } from '../../../utils';
import { InputSearch, InputSearchControls, } from '../InputSearch';
import { InputText } from '../InputText';
import { ComboboxContext } from './ComboboxContext';
import { getComboboxText } from './utils/getComboboxText';
import { makeHash } from './utils/makeHash';
import { ComboboxActionType, ComboboxState } from './utils/state';
import { useInputEvents } from './utils/useInputEvents';
import { useInputPropRefs } from './utils/useInputPropRefs';
export const ComboboxInputInternal = forwardRef((props, forwardedRef) => {
    const { autoComplete = true, readOnly = false, onClear, onChange, value: controlledValue } = props, rest = __rest(props, ["autoComplete", "readOnly", "onClear", "onChange", "value"]);
    const { data: { navigationOption, option, inputValue: contextInputValue }, onChange: contextOnChange, inputCallbackRef, state, transition, id, } = useContext(ComboboxContext);
    useInputPropRefs(props, ComboboxContext);
    const ref = useForkedRef(inputCallbackRef, forwardedRef);
    const isControlled = controlledValue !== undefined;
    function handleClear() {
        contextOnChange && contextOnChange(undefined);
        transition && transition(ComboboxActionType.CLEAR);
    }
    function handleValueChange(value) {
        transition && transition(ComboboxActionType.CHANGE, { inputValue: value });
    }
    const isInputting = useRef(false);
    if (controlledValue !== undefined &&
        contextInputValue &&
        controlledValue !== contextInputValue) {
        if (isInputting.current) {
            handleValueChange(controlledValue);
        }
        else {
            transition &&
                transition(ComboboxActionType.CHANGE_SILENT, {
                    inputValue: controlledValue,
                });
        }
    }
    function handleChange(event) {
        isInputting.current = true;
        if (!isControlled) {
            handleValueChange(event.currentTarget.value);
        }
        requestAnimationFrame(() => {
            isInputting.current = false;
        });
    }
    let inputOption = contextInputValue !== undefined ? contextInputValue : option;
    if (autoComplete &&
        (state === ComboboxState.NAVIGATING ||
            state === ComboboxState.INTERACTING)) {
        inputOption =
            navigationOption ||
                (controlledValue !== undefined ? controlledValue : option);
    }
    const inputValue = getComboboxText(inputOption);
    const wrappedOnClear = useWrapEvent(handleClear, onClear);
    const wrappedOnChange = useWrapEvent(handleChange, onChange);
    const inputEvents = useInputEvents(props, ComboboxContext);
    return (React.createElement(InputSearch, Object.assign({}, rest, inputEvents, { hideSearchIcon: true, ref: ref, value: inputValue, readOnly: readOnly, onClear: wrappedOnClear, onChange: wrappedOnChange, id: `listbox-${id}`, autoComplete: "off", "aria-autocomplete": "both", "aria-activedescendant": navigationOption
            ? String(makeHash(navigationOption ? navigationOption.value : ''))
            : undefined })));
});
ComboboxInputInternal.displayName = 'ComboboxInputInternal';
const indicatorRaw = `
<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M7.41 8.58984L12 13.1698L16.59 8.58984L18 9.99984L12 15.9998L6 9.99984L7.41 8.58984Z"
    fill="currentColor"
  />
</svg>`;
export const indicatorSize = '1rem';
export const indicatorPadding = '.5rem';
export const comboboxPaddingRight = `calc(2 * ${indicatorPadding} + ${indicatorSize})`;
const base64 = typeof window !== 'undefined' ? window.btoa : btoa;
const indicatorPrefix = 'data:image/svg+xml;base64,';
export const selectIndicatorBG = (color) => `url('${indicatorPrefix}${base64(indicatorRaw.replace('currentColor', color))}')`;
const bgPosition = `right ${indicatorPadding} top calc(${indicatorPadding} + 2px), 0 0`;
export const comboboxStyles = css `
  background-image: ${(props) => {
    const color = props.disabled
        ? props.theme.colors.palette.charcoal300
        : props.theme.colors.palette.charcoal500;
    return selectIndicatorBG(color);
}};
  background-repeat: no-repeat, repeat;
  background-position: ${bgPosition};
  background-size: ${indicatorSize}, 100%;
  padding-right: ${comboboxPaddingRight};

  ${InputText} {
    cursor: ${(props) => (props.readOnly ? 'default' : 'text')};
  }

  ${InputSearchControls} {
    &::after {
      content: ' ';
      border-right: 1px solid
        ${(props) => props.theme.colors.palette.charcoal200};
      height: 1.5rem;
      width: ${(props) => props.theme.space.xsmall};
      pointer-events: none;
    }
  }
`;
export const ComboboxInput = styled(ComboboxInputInternal).withConfig({ displayName: "ComboboxInput", componentId: "sc-686qay" }) `
  ${comboboxStyles}
`;
ComboboxInput.defaultProps = {
    width: '100%',
};
//# sourceMappingURL=ComboboxInput.js.map