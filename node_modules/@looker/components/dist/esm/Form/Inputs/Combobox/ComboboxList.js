var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { reset, space, typography, } from '@looker/design-tokens';
import React, { forwardRef, useContext, useLayoutEffect, useEffect, } from 'react';
import styled, { css } from 'styled-components';
import once from 'lodash/once';
import throttle from 'lodash/throttle';
import { PopoverContent, usePopover } from '../../../Popover';
import { ComboboxContext, ComboboxMultiContext } from './ComboboxContext';
import { useBlur } from './utils/useBlur';
import { useKeyDown } from './utils/useKeyDown';
import { ComboboxActionType } from './utils/state';
const ComboboxListInternal = forwardRef((_a, forwardedRef) => {
    var { persistSelection = false, closeOnSelect = true, windowedOptions = false, isMulti } = _a, props = __rest(_a, ["persistSelection", "closeOnSelect", "windowedOptions", "isMulti"]);
    const context = useContext(ComboboxContext);
    const contextMulti = useContext(ComboboxMultiContext);
    const contextToUse = isMulti ? contextMulti : context;
    const { persistSelectionPropRef, closeOnSelectPropRef, windowedOptionsPropRef, transition, wrapperElement, isVisible, optionsRef, popoverRef, setListScrollPosition, setListClientRect, } = contextToUse;
    if (persistSelectionPropRef)
        persistSelectionPropRef.current = persistSelection;
    if (closeOnSelectPropRef)
        closeOnSelectPropRef.current = closeOnSelect;
    if (windowedOptionsPropRef)
        windowedOptionsPropRef.current = windowedOptions;
    useLayoutEffect(() => {
        if (optionsRef)
            optionsRef.current = [];
        return () => {
            if (optionsRef)
                optionsRef.current = [];
        };
    }, [optionsRef, isVisible]);
    const handleKeyDown = useKeyDown();
    const handleBlur = useBlur();
    const width = wrapperElement
        ? wrapperElement.getBoundingClientRect().width
        : 'auto';
    const content = (React.createElement(PopoverContent, { width: width, onKeyDown: handleKeyDown, onBlur: handleBlur, ref: popoverRef, p: "none" },
        React.createElement("ul", Object.assign({}, props, { ref: forwardedRef, role: "listbox", tabIndex: -1, "data-testid": "combobox-list" }))));
    const setOpen = (isOpen) => {
        if (!isOpen) {
            transition && transition(ComboboxActionType.BLUR);
        }
    };
    const { popover, contentContainer, popperInstanceRef } = usePopover({
        arrow: false,
        content,
        focusTrap: false,
        isOpen: isVisible,
        placement: 'bottom',
        setOpen,
        triggerElement: wrapperElement,
        triggerToggle: false,
    });
    const valueLength = isMulti ? contextMulti.data.options.length : 1;
    useEffect(() => {
        popperInstanceRef.current && popperInstanceRef.current.update();
    }, [popperInstanceRef, valueLength]);
    useEffect(() => {
        const setListClientRectOnce = once((containerElement) => {
            setListClientRect &&
                setListClientRect(containerElement.getBoundingClientRect());
        });
        const scrollListener = throttle(() => {
            if (contentContainer) {
                setListClientRectOnce(contentContainer);
                setListScrollPosition &&
                    setListScrollPosition(contentContainer.scrollTop);
            }
        }, 50);
        if (contentContainer) {
            contentContainer.addEventListener('scroll', scrollListener);
            scrollListener();
        }
        return () => {
            contentContainer &&
                contentContainer.removeEventListener('scroll', scrollListener);
            setListScrollPosition && setListScrollPosition(0);
            setListClientRect && setListClientRect(undefined);
        };
    }, [contentContainer]);
    return popover || null;
});
ComboboxListInternal.displayName = 'ComboboxListInternal';
const comboboxListStyles = css `
  ${reset}
  ${typography}
  ${space}
  list-style-type: none;
  margin: 0;
  padding: ${({ isMulti, theme }) => (isMulti ? theme.space.xsmall : 0)} 0;
  max-height: 30rem;
`;
export const ComboboxList = styled(ComboboxListInternal).attrs({
    isMulti: false,
}).withConfig({ displayName: "ComboboxList", componentId: "sc-b0l5am" }) `
  ${comboboxListStyles}
`;
export const ComboboxMultiList = styled(ComboboxListInternal).attrs({
    isMulti: true,
}).withConfig({ displayName: "ComboboxMultiList", componentId: "sc-33fdbw" }) `
  ${comboboxListStyles}
`;
ComboboxList.defaultProps = {
    py: 'xsmall',
};
//# sourceMappingURL=ComboboxList.js.map