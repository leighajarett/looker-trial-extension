import React, { useState, useRef, useEffect } from 'react';
import { reset, space } from '@looker/design-tokens';
import styled from 'styled-components';
import sortBy from 'lodash/sortBy';
import indexOf from 'lodash/indexOf';
import startsWith from 'lodash/startsWith';
import partial from 'lodash/partial';
import map from 'lodash/map';
import isEqual from 'lodash/isEqual';
import { useMeasuredElement, useMouseDragPosition, usePreviousValue, useReadOnlyWarn, } from '../../../utils';
const sort = (arr) => arr.sort((a, b) => a - b);
const findClosestIndex = (value, newPoint) => {
    const { index: closestIndex } = sortBy(value.map((p, i) => ({
        distance: Math.abs(p - newPoint),
        index: i,
    })), 'distance')[0];
    return closestIndex;
};
const createNewValue = (value, newPoint, focusedIndex) => {
    const indexToReplace = focusedIndex === undefined
        ? findClosestIndex(value, newPoint)
        : focusedIndex;
    const newValue = Object.assign([], value, { [indexToReplace]: newPoint });
    return sort(newValue);
};
const roundToStep = (min, max, newPoint, step) => {
    const roundedPoint = Math.round((newPoint - min) / step) * step + min;
    return Math.max(Math.min(roundedPoint, max), min);
};
const calculatePointValue = (mouseX, containerRect, min, max, step) => {
    const mousePosition = mouseX - containerRect.left;
    const possibleValueRange = max - min;
    const newPoint = (mousePosition / containerRect.width) * possibleValueRange + min;
    return roundToStep(min, max, newPoint, step);
};
const boundValueProp = (min, max, value) => {
    return map(value || [min, max], (point) => {
        const boundedPoint = Math.max(Math.min(point, max), min);
        if (boundedPoint !== point) {
            console.warn(`<RangeSlider />: The value '${point}' falls outside the possible range (MIN: ${min}, MAX: ${max}). Please adjust min and max props accordingly.`);
        }
        return boundedPoint;
    });
};
export const InternalRangeSlider = ({ className, min = 0, max = 10, step = 1, value: valueProp, defaultValue: defaultValueProp, onChange, disabled = false, readOnly: readOnlyProp = false, 'aria-labelledby': ariaLabelledBy, }) => {
    const unintentionalReadOnly = useReadOnlyWarn('RangeSlider', valueProp, onChange);
    const readOnly = readOnlyProp || unintentionalReadOnly;
    const boundedValue = boundValueProp(min, max, valueProp || defaultValueProp);
    const [value, setValue] = useState(sort(boundedValue));
    const [containerRef, setContainerRef] = useState(null);
    const [focusedThumb, setFocusedThumb] = useState();
    const containerRect = useMeasuredElement(containerRef);
    const { mousePos, isMouseDown } = useMouseDragPosition(containerRef);
    const prevMouseDown = usePreviousValue(isMouseDown);
    const minThumbRef = useRef(null);
    const maxThumbRef = useRef(null);
    const [minValue, maxValue] = value;
    const minPos = ((minValue - min) / (max - min)) * containerRect.width;
    const maxPos = ((maxValue - min) / (max - min)) * containerRect.width;
    const fillWidth = maxPos - minPos;
    const thumbRefs = [minThumbRef, maxThumbRef];
    const focusChangedPoint = (newValue, newPoint) => {
        const indexToFocus = indexOf(newValue, newPoint);
        const refToFocus = thumbRefs[indexToFocus];
        requestAnimationFrame(() => {
            refToFocus.current && refToFocus.current.focus();
        });
    };
    const incrementPoint = (point) => {
        return Math.min(point + step, max);
    };
    const decrementPoint = (point) => {
        return Math.max(point - step, min);
    };
    const handleKeyboardNav = (e) => {
        if (!disabled && !readOnly) {
            if (startsWith(e.key, 'Arrow') && focusedThumb !== undefined) {
                e.preventDefault();
                const unfocusedThumb = focusedThumb === 0 ? 1 : 0;
                const mutationFn = e.key === 'ArrowUp' || e.key === 'ArrowRight'
                    ? incrementPoint
                    : decrementPoint;
                const newPoint = mutationFn(value[focusedThumb]);
                const newValue = sort([newPoint, value[unfocusedThumb]]);
                focusChangedPoint(newValue, newPoint);
                setValue(newValue);
            }
        }
    };
    const focusMinThumb = () => {
        if (!disabled && !readOnly) {
            setFocusedThumb(0);
        }
    };
    const focusMaxThumb = () => {
        if (!disabled && !readOnly) {
            setFocusedThumb(1);
        }
    };
    const handleBlur = () => {
        setFocusedThumb(undefined);
    };
    const handleMouseEvent = (maintainFocus) => {
        if (!disabled && !readOnly) {
            const newPoint = calculatePointValue(mousePos.x, containerRect, min, max, step);
            const newValue = createNewValue(value, newPoint, maintainFocus ? focusedThumb : undefined);
            focusChangedPoint(newValue, newPoint);
            setValue(newValue);
        }
    };
    const handleMouseDown = partial(handleMouseEvent, false);
    const handleMouseDrag = partial(handleMouseEvent, true);
    useEffect(() => {
        if (isMouseDown && prevMouseDown) {
            handleMouseDrag();
        }
    }, [mousePos, isMouseDown]);
    useEffect(() => {
        const boundedValue = boundValueProp(min, max, valueProp);
        if (!isEqual(value, boundedValue)) {
            setValue(sort(boundedValue));
        }
    }, [valueProp]);
    useEffect(() => {
        if (!isEqual(value, valueProp)) {
            onChange && onChange(value);
        }
    }, [value]);
    return (React.createElement("div", { "data-testid": "range-slider-wrapper", onMouseDown: handleMouseDown, className: className, ref: setContainerRef },
        React.createElement(SliderTrack, null,
            React.createElement(SliderFill, { fillStart: minPos, fillWidth: fillWidth, disabled: disabled }),
            React.createElement(ThumbLabel, { position: minPos, focus: focusedThumb === 0, disabled: disabled }, minValue),
            React.createElement(ThumbLabel, { position: maxPos, focus: focusedThumb === 1, disabled: disabled }, maxValue),
            React.createElement(Thumb, { position: minPos, tabIndex: (disabled ? '-1' : '0'), onFocus: focusMinThumb, onBlur: handleBlur, onKeyDown: handleKeyboardNav, ref: minThumbRef, disabled: disabled, "aria-label": "Minimum Value", role: "slider", "aria-valuemin": min, "aria-valuemax": max, "aria-disabled": disabled, "aria-valuenow": value[0], "aria-labelledBy": ariaLabelledBy }),
            React.createElement(Thumb, { position: maxPos, tabIndex: (disabled ? '-1' : '0'), onFocus: focusMaxThumb, onBlur: handleBlur, onKeyDown: handleKeyboardNav, ref: maxThumbRef, disabled: disabled, "aria-label": "Maximum Value", role: "slider", "aria-valuemin": min, "aria-valuemax": max, "aria-disabled": disabled, "aria-valuenow": value[1], "aria-labelledby": ariaLabelledBy }))));
};
export const RangeSlider = styled(InternalRangeSlider).withConfig({ displayName: "RangeSlider", componentId: "sc-aiqru1" }) `
  ${reset}
  ${space}
  padding: ${({ theme: { space } }) => `${space.xlarge} 0 ${space.small}`};
  max-width: 500px;
`;
const SliderTrack = styled.div.withConfig({ displayName: "SliderTrack", componentId: "sc-1ltg0tt" }) `
  height: 4px;
  background: ${({ theme }) => theme.colors.palette.charcoal200};
  border-radius: 2px;
  position: relative;
`;
const ThumbLabel = styled.div.withConfig({ displayName: "ThumbLabel", componentId: "sc-z0gnc1" }) `
  user-select: none;
  position: absolute;
  top: -30px;
  transform: translateX(calc(${({ position = 0 }) => `${position}px`} - 50%));
  text-align: center;
  color: ${({ theme: { colors }, disabled }) => disabled ? colors.palette.charcoal700 : colors.semanticColors.primary.main};
  padding: 0 0.5rem;
  border-radius: 1rem;
  z-index: ${({ focus }) => (focus ? 1 : 0)};
  background: ${({ theme, focus }) => focus ? theme.colors.palette.purple100 : `rgba(255, 255, 255, 0.8)`};
`;
const Thumb = styled.div.withConfig({ displayName: "Thumb", componentId: "sc-1m2uy74" }) `
  border-radius: 100%;
  cursor: pointer;
  border: 3px solid
    ${({ theme: { colors }, disabled }) => disabled
    ? colors.palette.charcoal500
    : colors.semanticColors.primary.main};
  height: 16px;
  width: 16px;
  background: ${({ theme }) => theme.colors.palette.white};
  position: absolute;
  top: -6px;
  margin-left: -8px;
  transform: translateX(${({ position = 0 }) => `${position}px`});
  &:focus {
    outline: none;
    border-width: ${({ disabled }) => (disabled ? '3px' : '5px')};
    z-index: 1;
  }
`;
const SliderFill = styled.div.withConfig({ displayName: "SliderFill", componentId: "sc-1dygz3g" }) `
  height: 100%;
  background: ${({ theme: { colors }, disabled }) => disabled ? colors.palette.charcoal400 : colors.semanticColors.primary.main};
  position: absolute;
  left: ${({ fillStart }) => fillStart}px;
  width: ${({ fillWidth }) => fillWidth}px;
`;
//# sourceMappingURL=RangeSlider.js.map