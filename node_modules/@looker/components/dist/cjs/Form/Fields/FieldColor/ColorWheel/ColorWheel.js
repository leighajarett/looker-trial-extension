"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const styled_components_1 = __importDefault(require("styled-components"));
const d3_hsv_1 = require("d3-hsv");
const canvas_utils_1 = require("./canvas_utils");
const color_wheel_utils_1 = require("./color_wheel_utils");
const math_utils_1 = require("./math_utils");
class ColorWheel extends react_1.Component {
    constructor() {
        super(...arguments);
        this.isMouseDragging = false;
        this.setColorWheelCanvasRef = (element) => {
            this.colorWheelCanvas = element;
        };
        this.setValueCanvasRef = (element) => {
            this.valueCanvas = element;
        };
        this.setCompositeCanvasRef = (element) => {
            this.compositeCanvas = element;
        };
        this.setMarkerCanvasRef = (element) => {
            this.markerCanvas = element;
        };
        this.mouseDown = (event) => {
            this.setMouseDragging(true);
            const canvasCartesian = canvas_utils_1.eventCartesianPosition(this.colorWheelCanvas, event);
            const position = math_utils_1.limitByRadius(math_utils_1.translateDiagonal(-canvas_utils_1.canvasMargin, canvasCartesian), this.radius);
            this.updateColor(position, this.props.onColorChange);
        };
        this.mouseMove = (event) => {
            if (this.isMouseDragging) {
                const canvasCartesian = canvas_utils_1.eventCartesianPosition(this.colorWheelCanvas, event);
                const position = math_utils_1.limitByRadius(math_utils_1.translateDiagonal(-canvas_utils_1.canvasMargin, canvasCartesian), this.radius);
                this.updateColor(position, this.props.onColorChange);
            }
        };
        this.setMouseDragging = (isDragging) => {
            this.isMouseDragging = isDragging;
        };
        this.drawValueLayer = () => {
            canvas_utils_1.clearCanvas(this.valueCanvas);
            const ctx = this.valueCanvas.getContext('2d');
            const centerX = this.valueCanvas.width / 2;
            const centerY = this.valueCanvas.height / 2;
            if (ctx) {
                const { r, g, b } = d3_hsv_1.hsv(0, 0, this.props.value).rgb();
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.radius, 0, 2 * Math.PI, false);
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fill();
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#ffffff';
                ctx.stroke();
            }
        };
        this.drawCompositeCanvas = () => {
            canvas_utils_1.clearCanvas(this.compositeCanvas);
            const ctx = this.compositeCanvas.getContext('2d');
            if (ctx) {
                ctx.globalCompositeOperation = 'multiply';
                ctx.drawImage(this.colorWheelCanvas, 0, 0);
                ctx.drawImage(this.valueCanvas, 0, 0);
            }
        };
    }
    componentDidMount() {
        this.drawWheel();
        this.drawValueLayer();
        this.drawCompositeCanvas();
        this.drawMouseMarker();
    }
    componentDidUpdate() {
        this.drawValueLayer();
        this.drawCompositeCanvas();
        this.drawMouseMarker();
    }
    render() {
        return (react_1.default.createElement(ColorWheelWrapper, { size: this.props.size },
            react_1.default.createElement(Canvas, { ref: this.setColorWheelCanvasRef, width: this.props.size, height: this.props.size }),
            react_1.default.createElement(Canvas, { ref: this.setValueCanvasRef, width: this.props.size, height: this.props.size }),
            react_1.default.createElement(Canvas, { ref: this.setCompositeCanvasRef, width: this.props.size, height: this.props.size }),
            react_1.default.createElement(Canvas, { "data-testid": "mouse-marker", ref: this.setMarkerCanvasRef, width: this.props.size, height: this.props.size, onMouseDown: this.mouseDown, onMouseMove: this.mouseMove, onMouseUp: this.setMouseDragging.bind(this, false), onMouseLeave: this.setMouseDragging.bind(this, false) })));
    }
    get radius() {
        return this.colorWheelCanvas
            ? canvas_utils_1.canvasRadius(this.colorWheelCanvas, canvas_utils_1.canvasMargin)
            : 0;
    }
    drawWheel() {
        const ctx = this.colorWheelCanvas.getContext('2d');
        if (!ctx)
            return;
        const image = this.getColorWheelImage();
        if (image) {
            ctx.putImageData(image, canvas_utils_1.canvasMargin, canvas_utils_1.canvasMargin);
        }
        ctx.beginPath();
        ctx.arc(this.colorWheelCanvas.width / 2, this.colorWheelCanvas.width / 2, this.radius, 0, 2 * Math.PI, false);
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#ffffff';
        ctx.stroke();
    }
    getColorWheelImage() {
        const ctx = this.colorWheelCanvas.getContext('2d');
        if (!this.colorWheelImage && ctx) {
            const colorValue = 1;
            this.colorWheelImage = ctx.createImageData(math_utils_1.diameter(this.radius), math_utils_1.diameter(this.radius));
            canvas_utils_1.drawColorWheelIntoCanvasImage(this.colorWheelImage.data, color_wheel_utils_1.generateColorWheel(this.radius, colorValue));
        }
        return this.colorWheelImage;
    }
    drawMouseMarker() {
        canvas_utils_1.clearCanvas(this.markerCanvas);
        const canvasCartesian = color_wheel_utils_1.hsv2cartesian(this.radius, {
            h: this.props.hue,
            s: this.props.saturation,
            v: this.props.value,
        });
        const mousePosition = math_utils_1.translateDiagonal(canvas_utils_1.canvasMargin, canvasCartesian);
        const ctx = this.markerCanvas.getContext('2d');
        if (ctx && mousePosition) {
            const mouseRadius = 4;
            ctx.beginPath();
            ctx.arc(mousePosition.x, mousePosition.y, mouseRadius, 0, 2 * Math.PI, false);
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#FFFFFF';
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(mousePosition.x, mousePosition.y, mouseRadius - 1, 0, 2 * Math.PI, false);
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#000000';
            ctx.stroke();
        }
    }
    updateColor(position, callback) {
        if (callback && position) {
            const color = color_wheel_utils_1.cartesian2hsv(this.props.value, this.radius, position);
            const updateColorValues = { h: color.h, s: color.s };
            callback(updateColorValues);
        }
    }
}
exports.ColorWheel = ColorWheel;
ColorWheel.defaultProps = {
    hue: 0,
    saturation: 1,
    size: 100,
    value: 1,
};
const ColorWheelWrapper = styled_components_1.default.div.withConfig({ displayName: "ColorWheelWrapper", componentId: "sc-mvegwn" }) `
  position: relative;
  width: ${({ size }) => size}px;
  height: ${({ size }) => size}px;
`;
const Canvas = styled_components_1.default.canvas.withConfig({ displayName: "Canvas", componentId: "sc-g7rz2m" }) `
  position: absolute;
  left: 0;
  top: 0;
`;
//# sourceMappingURL=ColorWheel.js.map