"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const d3color = __importStar(require("d3-color"));
const d3hsv = __importStar(require("d3-hsv"));
const math_utils_1 = require("./math_utils");
const named_colors_1 = require("./named_colors");
var ColorFormat;
(function (ColorFormat) {
    ColorFormat[ColorFormat["NAME"] = 0] = "NAME";
    ColorFormat[ColorFormat["HEX3"] = 1] = "HEX3";
    ColorFormat[ColorFormat["HEX6"] = 2] = "HEX6";
    ColorFormat[ColorFormat["RGBI"] = 3] = "RGBI";
    ColorFormat[ColorFormat["RGBIA"] = 4] = "RGBIA";
    ColorFormat[ColorFormat["RGBP"] = 5] = "RGBP";
    ColorFormat[ColorFormat["RGBPA"] = 6] = "RGBPA";
    ColorFormat[ColorFormat["HSL"] = 7] = "HSL";
    ColorFormat[ColorFormat["HSLA"] = 8] = "HSLA";
    ColorFormat[ColorFormat["TRANSPARENT"] = 9] = "TRANSPARENT";
    ColorFormat[ColorFormat["BAD"] = 10] = "BAD";
})(ColorFormat = exports.ColorFormat || (exports.ColorFormat = {}));
const RGB_MAX_VALUE = 255;
const recognize = (format) => {
    const reI = '\\s*([+-]?\\d+)\\s*';
    const reN = '\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*';
    const reP = '\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*';
    const reHex3 = /^#([0-9a-f]{3})$/;
    const reHex6 = /^#([0-9a-f]{6})$/;
    const reRgbInteger = new RegExp('^rgb\\(' + [reI, reI, reI] + '\\)$');
    const reRgbPercent = new RegExp('^rgb\\(' + [reP, reP, reP] + '\\)$');
    const reRgbaInteger = new RegExp('^rgba\\(' + [reI, reI, reI, reN] + '\\)$');
    const reRgbaPercent = new RegExp('^rgba\\(' + [reP, reP, reP, reN] + '\\)$');
    const reRgbaPercent2 = new RegExp('^rgba\\(' + [reP, reP, reP, reP] + '\\)$');
    const reHslPercent = new RegExp('^hsl\\(' + [reN, reP, reP] + '\\)$');
    const reHslaPercent = new RegExp('^hsla\\(' + [reN, reP, reP, reN] + '\\)$');
    format = String(format).trim().toLowerCase();
    return reHex3.exec(format)
        ? ColorFormat.HEX3
        : reHex6.exec(format)
            ? ColorFormat.HEX6
            : reRgbInteger.exec(format)
                ? ColorFormat.RGBI
                : reRgbPercent.exec(format)
                    ? ColorFormat.RGBP
                    : reRgbaInteger.exec(format)
                        ? ColorFormat.RGBIA
                        : reRgbaPercent.exec(format)
                            ? ColorFormat.RGBPA
                            : reRgbaPercent2.exec(format)
                                ? ColorFormat.RGBPA
                                : reHslPercent.exec(format)
                                    ? ColorFormat.HSL
                                    : reHslaPercent.exec(format)
                                        ? ColorFormat.HSLA
                                        : Object.prototype.hasOwnProperty.call(named_colors_1.namedColors, format)
                                            ? ColorFormat.NAME
                                            : format === 'transparent'
                                                ? ColorFormat.TRANSPARENT
                                                : ColorFormat.BAD;
};
exports.getFormat = (value) => ColorFormat[recognize(value)];
exports.getOpacity = (color) => {
    if (color instanceof d3color.cubehelix ||
        color instanceof d3color.hcl ||
        color instanceof d3color.hsl ||
        color instanceof d3color.rgb ||
        color instanceof d3color.lab) {
        return color.opacity;
    }
    return 1;
};
const namedColorLookup = (color) => {
    const hex = color.hex().replace(/^#/, '');
    const lookup = parseInt(hex, 16);
    const namedColorsFlipped = new Map(Object.entries(named_colors_1.namedColors).map(([k, v]) => [v, k]));
    return namedColorsFlipped.get(lookup);
};
exports.toColorName = (color, opacity = null) => {
    const opacityUse = opacity || exports.getOpacity(color);
    const name = namedColorLookup(color);
    if (name)
        return name;
    if (opacityUse !== 1)
        return d3color.rgb(color).toString();
    return color.hex();
};
exports.toRGBIString = (color, opacity = null, useAlpha = false) => {
    const opacityUse = opacity || exports.getOpacity(color);
    const rgb = color.rgb();
    const r = Math.round(rgb.r);
    const g = Math.round(rgb.g);
    const b = Math.round(rgb.b);
    if (useAlpha || opacityUse !== 1) {
        return `rgba(${r}, ${g}, ${b}, ${opacityUse})`;
    }
    return `rgb(${r}, ${g}, ${b})`;
};
exports.toRGBPString = (color, opacity = null, useAlpha = false) => {
    const opacityUse = opacity || exports.getOpacity(color);
    const rgb = color.rgb();
    const r = math_utils_1.toPercent(rgb.r, RGB_MAX_VALUE);
    const g = math_utils_1.toPercent(rgb.g, RGB_MAX_VALUE);
    const b = math_utils_1.toPercent(rgb.b, RGB_MAX_VALUE);
    if (useAlpha || opacityUse !== 1) {
        return `rgba(${r}%, ${g}%, ${b}%, ${opacityUse})`;
    }
    return `rgb(${r}%, ${g}%, ${b}%)`;
};
exports.toHSLString = (color, opacity = null, useAlpha = false) => {
    const opacityUse = opacity || exports.getOpacity(color);
    const hsl = d3color.hsl(color);
    const h = isNaN(hsl.h) ? 0 : hsl.h;
    const s = isNaN(hsl.s) ? 0 : Math.round(hsl.s * 100);
    const l = isNaN(hsl.l) ? 100 : Math.round(hsl.l * 100);
    if (useAlpha || opacityUse !== 1) {
        return `hsla(${h}, ${s}%, ${l}%, ${opacityUse})`;
    }
    return `hsl(${h}, ${s}%, ${l}%)`;
};
exports.toFormattedColorString = (value, format = null) => {
    const color = d3color.color(value);
    if (!color)
        return '';
    if (!color.displayable)
        return '';
    if (format === null)
        format = recognize(value);
    const opacity = exports.getOpacity(color);
    switch (format) {
        case ColorFormat.NAME:
        case ColorFormat.TRANSPARENT:
            return exports.toColorName(color);
        case ColorFormat.HEX3:
        case ColorFormat.HEX6:
            if (opacity === 1)
                return color.hex();
            return color.rgb().toString();
        case ColorFormat.RGBI:
            return color.rgb().toString();
        case ColorFormat.RGBIA:
            return exports.toRGBIString(color, opacity, true);
        case ColorFormat.RGBP:
            return exports.toRGBPString(color, opacity);
        case ColorFormat.RGBPA:
            return exports.toRGBPString(color, opacity, true);
        case ColorFormat.HSL:
            return exports.toHSLString(color, opacity);
        case ColorFormat.HSLA:
            return exports.toHSLString(color, opacity, true);
        default:
            return color.toString();
    }
};
exports.toHSV = (value) => {
    const color = d3color.color(value);
    if (!color)
        return null;
    return d3hsv.hsv(color);
};
exports.hsvToColorString = (hsvColor, format = null) => exports.toFormattedColorString(hsvColor.rgb().toString(), format);
exports.hsv2hex = (color) => d3hsv.hsv(color.h, color.s, color.v).hex();
exports.str2simpleHsv = (color) => {
    const hsvColor = d3hsv.hsv(color);
    const simpleHSV = { h: hsvColor.h, s: hsvColor.s, v: hsvColor.v };
    return simpleHSV;
};
exports.simpleHSVtoRGB = (color) => d3hsv.hsv(color.h, color.s, color.v).rgb();
exports.simpleHSVtoFormattedColorString = (color, colorFormat) => {
    const rgbColor = exports.simpleHSVtoRGB(color);
    switch (colorFormat) {
        case 'NAME':
            return exports.toColorName(rgbColor);
        case 'RGBI':
        case 'RGBIA':
            return exports.toRGBIString(rgbColor);
        case 'RGBP':
        case 'RGBPA':
            return exports.toRGBPString(rgbColor);
        case 'HSL':
        case 'HSLA':
            return exports.toHSLString(rgbColor);
        case 'HEX3':
        case 'HEX6':
        default:
            return rgbColor.hex();
    }
};
//# sourceMappingURL=color_format_utils.js.map