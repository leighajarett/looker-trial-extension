"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const styled_components_1 = __importDefault(require("styled-components"));
const utils_1 = require("../../../utils");
const Layout_1 = require("../../../Layout");
const InputChips_1 = require("../InputChips");
const InputSearch_1 = require("../InputSearch");
const ComboboxContext_1 = require("./ComboboxContext");
const ComboboxInput_1 = require("./ComboboxInput");
const getComboboxText_1 = require("./utils/getComboboxText");
const makeHash_1 = require("./utils/makeHash");
const state_1 = require("./utils/state");
const useInputEvents_1 = require("./utils/useInputEvents");
const useInputPropRefs_1 = require("./utils/useInputPropRefs");
exports.ComboboxMultiInputInternal = react_1.forwardRef((props, forwardedRef) => {
    const { autoComplete = true, readOnly = false, onClear, onInputChange, inputValue: controlledInputValue } = props, rest = __rest(props, ["autoComplete", "readOnly", "onClear", "onInputChange", "inputValue"]);
    const { data: { navigationOption, options, inputValue: contextInputValue }, onChange: contextOnChange, inputCallbackRef, state, transition, id, } = react_1.useContext(ComboboxContext_1.ComboboxMultiContext);
    useInputPropRefs_1.useInputPropRefs(props, ComboboxContext_1.ComboboxMultiContext);
    function handleClear() {
        transition && transition(state_1.ComboboxActionType.CLEAR);
        contextOnChange && contextOnChange([]);
    }
    function handleChange(values) {
        transition &&
            transition(state_1.ComboboxActionType.CHANGE_VALUES, { inputValues: values });
        const newOptions = options.filter((option) => values.includes(getComboboxText_1.getComboboxText(option)));
        contextOnChange && contextOnChange(newOptions);
    }
    const handleInputValueChange = react_1.useCallback((value) => {
        transition &&
            transition(state_1.ComboboxActionType.CHANGE, { inputValue: value });
    }, [transition]);
    const isInputting = react_1.useRef(false);
    if (controlledInputValue !== undefined &&
        contextInputValue &&
        controlledInputValue !== contextInputValue) {
        if (isInputting.current) {
            handleInputValueChange(controlledInputValue);
        }
        else {
            transition &&
                transition(state_1.ComboboxActionType.CHANGE_SILENT, {
                    inputValue: controlledInputValue,
                });
        }
    }
    const isControlled = controlledInputValue !== undefined;
    const handleInputChange = react_1.useCallback((value) => {
        isInputting.current = true;
        if (!isControlled) {
            handleInputValueChange(value);
        }
        requestAnimationFrame(() => {
            isInputting.current = false;
        });
    }, [handleInputValueChange, isControlled]);
    const inputValues = options.map((option) => getComboboxText_1.getComboboxText(option));
    let inputValue = contextInputValue || '';
    if (autoComplete &&
        (state === state_1.ComboboxState.NAVIGATING ||
            state === state_1.ComboboxState.INTERACTING) &&
        navigationOption) {
        inputValue = getComboboxText_1.getComboboxText(navigationOption);
    }
    const wrappedOnClear = utils_1.useWrapEvent(handleClear, onClear);
    const wrappedOnInputChange = react_1.useCallback((value) => {
        handleInputChange(value);
        onInputChange && onInputChange(value);
    }, [handleInputChange, onInputChange]);
    const inputEvents = useInputEvents_1.useInputEvents(props, ComboboxContext_1.ComboboxMultiContext);
    const ref = utils_1.useForkedRef(inputCallbackRef, forwardedRef);
    return (react_1.default.createElement(InputChips_1.InputChipsBase, Object.assign({}, rest, inputEvents, { ref: ref, readOnly: readOnly, values: inputValues, onChange: handleChange, onClear: wrappedOnClear, inputValue: inputValue, onInputChange: wrappedOnInputChange, id: `listbox-${id}`, autoComplete: "off", "aria-autocomplete": "both", "aria-activedescendant": navigationOption
            ? String(makeHash_1.makeHash(navigationOption ? navigationOption.value : ''))
            : undefined })));
});
exports.ComboboxMultiInputInternal.displayName = 'ComboboxMultiInputInternal';
exports.ComboboxMultiInput = styled_components_1.default(exports.ComboboxMultiInputInternal).withConfig({ displayName: "ComboboxMultiInput", componentId: "sc-bctbg9" }) `
  ${ComboboxInput_1.comboboxStyles}
  padding-right: 0;

  ${Layout_1.Flex} {
    padding-right: calc(${(props) => props.theme.space.xlarge} * 2);
  }

  ${InputSearch_1.InputSearchControls} {
    right: ${ComboboxInput_1.comboboxPaddingRight};
  }
`;
exports.ComboboxMultiInput.defaultProps = {
    width: '100%',
};
//# sourceMappingURL=ComboboxMultiInput.js.map