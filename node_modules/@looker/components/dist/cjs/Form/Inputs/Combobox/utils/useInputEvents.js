"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("react");
const utils_1 = require("../../../../utils");
const state_1 = require("./state");
const useBlur_1 = require("./useBlur");
const useKeyDown_1 = require("./useKeyDown");
function checkForButton(element, containingAncestor) {
    if (element === containingAncestor)
        return false;
    if (!element.parentElement)
        return false;
    if (element.tagName === 'BUTTON') {
        return true;
    }
    return checkForButton(element.parentElement, containingAncestor);
}
function useInputEvents({ selectOnClick = false, readOnly = false, onClick, onMouseDown, onKeyDown, onBlur, onFocus, }, context) {
    const { data: { lastActionType }, inputElement, openOnFocus, persistSelectionPropRef, state, transition, } = react_1.useContext(context);
    const selectOnClickRef = react_1.useRef(false);
    const handleKeyDown = useKeyDown_1.useKeyDown();
    const handleBlur = useBlur_1.useBlur();
    function handleFocus(e) {
        if (readOnly) {
            e.currentTarget.selectionEnd = e.currentTarget.selectionStart;
        }
        else if (selectOnClick) {
            selectOnClickRef.current = true;
        }
        if (openOnFocus &&
            lastActionType !== state_1.ComboboxActionType.SELECT_WITH_CLICK &&
            lastActionType !== state_1.ComboboxActionType.NAVIGATE) {
            transition &&
                transition(state_1.ComboboxActionType.FOCUS, {
                    persistSelection: persistSelectionPropRef && persistSelectionPropRef.current,
                });
        }
    }
    const selectText = react_1.useCallback(() => {
        if (selectOnClickRef.current) {
            selectOnClickRef.current = false;
            inputElement && inputElement.select();
        }
    }, [inputElement]);
    const handleMouseDownClick = react_1.useCallback((e) => {
        if (checkForButton(e.target, e.currentTarget)) {
            return;
        }
        if (state === state_1.ComboboxState.IDLE) {
            transition &&
                transition(state_1.ComboboxActionType.FOCUS, {
                    persistSelection: persistSelectionPropRef && persistSelectionPropRef.current,
                });
        }
        else {
            transition && transition(state_1.ComboboxActionType.ESCAPE);
        }
        if (e.type === 'click') {
            selectText();
        }
    }, [persistSelectionPropRef, state, selectText, transition]);
    const handleMouseUp = react_1.useCallback((e) => {
        if (e.target === inputElement) {
            selectText();
        }
    }, [inputElement, selectText]);
    const { onMouseDown: handleMouseDown, onClick: handleClick, } = utils_1.useMouseDownClick(handleMouseDownClick, handleMouseUp);
    const wrappedOnBlur = utils_1.useWrapEvent(handleBlur, onBlur);
    const wrappedOnClick = utils_1.useWrapEvent(handleClick, onClick);
    const wrappedOnFocus = utils_1.useWrapEvent(handleFocus, onFocus);
    const wrappedOnMouseDown = utils_1.useWrapEvent(handleMouseDown, onMouseDown);
    const wrappedOnKeyDown = utils_1.useWrapEvent(handleKeyDown, onKeyDown);
    return {
        onBlur: wrappedOnBlur,
        onClick: wrappedOnClick,
        onFocus: wrappedOnFocus,
        onKeyDown: wrappedOnKeyDown,
        onMouseDown: wrappedOnMouseDown,
    };
}
exports.useInputEvents = useInputEvents;
//# sourceMappingURL=useInputEvents.js.map