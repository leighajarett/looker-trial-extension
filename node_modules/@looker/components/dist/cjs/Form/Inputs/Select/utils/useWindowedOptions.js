"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const findIndex_1 = __importDefault(require("lodash/findIndex"));
const react_1 = __importStar(require("react"));
const getWindowedListBoundaries_1 = require("../../../../utils/getWindowedListBoundaries");
const Combobox_1 = require("../../Combobox");
exports.optionHeight = 28;
function useShouldWindowOptions(options, propsWindowedOptions) {
    return react_1.useMemo(() => {
        if (!options)
            return false;
        if (propsWindowedOptions === false)
            return false;
        if (options.length < 100 && !propsWindowedOptions)
            return false;
        const groupedOptions = options.find((option) => option.options !== undefined);
        if (groupedOptions) {
            if (propsWindowedOptions) {
                console.warn('The `windowedOptions` prop does not support grouped options.');
            }
            return false;
        }
        return true;
    }, [options, propsWindowedOptions]);
}
exports.useShouldWindowOptions = useShouldWindowOptions;
function useWindowedOptions(windowedOptions, options, isMulti) {
    const context = react_1.useContext(Combobox_1.ComboboxContext);
    const contextMulti = react_1.useContext(Combobox_1.ComboboxMultiContext);
    const contextToUse = isMulti ? contextMulti : context;
    const { data: { navigationOption }, listClientRect, listScrollPosition, optionsRef, } = contextToUse;
    const flatOptions = options;
    react_1.useEffect(() => {
        if (windowedOptions &&
            flatOptions &&
            flatOptions.length > 0 &&
            optionsRef) {
            optionsRef.current = [...flatOptions];
        }
    }, [flatOptions, optionsRef, windowedOptions]);
    const containerHeight = listClientRect && listClientRect.height;
    let { start, end } = react_1.useMemo(() => getWindowedListBoundaries_1.getWindowedListBoundaries({
        containerHeight,
        containerScrollPosition: listScrollPosition,
        enabled: windowedOptions,
        itemHeight: exports.optionHeight,
        length: flatOptions ? flatOptions.length : 0,
    }), [flatOptions, containerHeight, listScrollPosition, windowedOptions]);
    const isFirstRender = react_1.useRef(true);
    if (windowedOptions && isFirstRender.current) {
        if (navigationOption) {
            const selectedIndex = findIndex_1.default(options, [
                'value',
                navigationOption.value,
            ]);
            start = selectedIndex;
            end = selectedIndex;
        }
        isFirstRender.current = false;
    }
    let scrollToFirst = false;
    let scrollToLast = false;
    if (windowedOptions &&
        flatOptions &&
        flatOptions.length &&
        navigationOption) {
        scrollToFirst = start > 0 && navigationOption.value === flatOptions[0].value;
        scrollToLast =
            end < flatOptions.length - 1 &&
                navigationOption.value === flatOptions[flatOptions.length - 1].value;
    }
    const afterLength = flatOptions ? flatOptions.length - 1 - end : 0;
    return {
        after: afterLength > 0 ? (react_1.default.createElement("li", { style: { height: `${afterLength * exports.optionHeight}px` } })) : null,
        before: start > 0 ? react_1.default.createElement("li", { style: { height: `${start * exports.optionHeight}px` } }) : null,
        end,
        scrollToFirst,
        scrollToLast,
        start,
    };
}
exports.useWindowedOptions = useWindowedOptions;
//# sourceMappingURL=useWindowedOptions.js.map