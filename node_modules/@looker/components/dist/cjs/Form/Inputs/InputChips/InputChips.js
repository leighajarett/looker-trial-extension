"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const styled_components_1 = __importDefault(require("styled-components"));
const utils_1 = require("../../../utils");
const InputChipsBase_1 = require("./InputChipsBase");
function getUpdatedValues(inputValue, currentValues, validate) {
    const duplicateValues = [];
    const invalidValues = [];
    const unusedValues = [];
    const validValues = [];
    const inputValues = inputValue.split(/[,\t]+/);
    inputValues.forEach((val) => {
        const trimmedValue = val.trim();
        if (trimmedValue === '')
            return;
        if (validate && !validate(trimmedValue)) {
            unusedValues.push(trimmedValue);
            return invalidValues.push(trimmedValue);
        }
        else if (currentValues && currentValues.includes(trimmedValue)) {
            unusedValues.push(trimmedValue);
            return duplicateValues.push(trimmedValue);
        }
        else {
            return validValues.push(trimmedValue);
        }
    });
    return { duplicateValues, invalidValues, unusedValues, validValues };
}
exports.InputChipsInternal = react_1.forwardRef((_a, ref) => {
    var { values, onChange, onKeyDown, inputValue: controlledInputValue, onInputChange, validate, onValidationFail, onDuplicate } = _a, props = __rest(_a, ["values", "onChange", "onKeyDown", "inputValue", "onInputChange", "validate", "onValidationFail", "onDuplicate"]);
    const isControlled = utils_1.useControlWarn({
        controllingProps: ['inputValue', 'onInputChange'],
        isControlledCheck: () => controlledInputValue !== undefined && onInputChange !== undefined,
        name: 'InputChips',
    });
    const [uncontrolledValue, setUncontrolledValue] = react_1.useState('');
    const inputValue = isControlled
        ? controlledInputValue || ''
        : uncontrolledValue;
    const setInputValue = (val) => {
        if (!isControlled) {
            setUncontrolledValue(val);
        }
        onInputChange && onInputChange(val);
    };
    function updateValues(newInputValue) {
        const { duplicateValues, invalidValues, unusedValues, validValues, } = getUpdatedValues(newInputValue || inputValue, values, validate);
        const updatedInputValue = unusedValues.join(', ');
        const updatedValues = validValues.length && [...values, ...validValues];
        if (updatedValues) {
            onChange(updatedValues);
        }
        if (invalidValues.length > 0) {
            onValidationFail && onValidationFail(invalidValues);
        }
        if (duplicateValues.length > 0) {
            onDuplicate && onDuplicate(duplicateValues);
        }
        setInputValue(updatedInputValue);
    }
    function handleBlur() {
        updateValues();
    }
    function handleKeyDown(e) {
        onKeyDown && onKeyDown(e);
        if (e.key === 'Enter') {
            e.preventDefault();
            updateValues();
        }
    }
    const isPasting = react_1.default.useRef(false);
    function handlePaste() {
        isPasting.current = true;
    }
    function handleInputChange(value) {
        if (isPasting.current || value.endsWith(',')) {
            updateValues(value);
            isPasting.current = false;
        }
        else {
            setInputValue(value);
        }
    }
    return (react_1.default.createElement(InputChipsBase_1.InputChipsBase, Object.assign({ ref: ref, values: values, onChange: onChange, inputValue: inputValue, onInputChange: handleInputChange, onBlur: handleBlur, onKeyDown: handleKeyDown, onPaste: handlePaste }, props)));
});
exports.InputChipsInternal.displayName = 'InputChipsInternal';
exports.InputChips = styled_components_1.default(exports.InputChipsInternal).withConfig({ displayName: "InputChips", componentId: "sc-1cs4hsy" }) ``;
//# sourceMappingURL=InputChips.js.map