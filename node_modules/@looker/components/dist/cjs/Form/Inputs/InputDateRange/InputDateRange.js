"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const styled_components_1 = __importDefault(require("styled-components"));
const isFunction_1 = __importDefault(require("lodash/isFunction"));
const partial_1 = __importDefault(require("lodash/partial"));
const min_1 = __importDefault(require("lodash/min"));
const max_1 = __importDefault(require("lodash/max"));
const isEqual_1 = __importDefault(require("lodash/isEqual"));
const values_1 = __importDefault(require("lodash/values"));
const design_tokens_1 = require("@looker/design-tokens");
const InputText_1 = require("../InputText");
const Calendar_1 = require("../../../Calendar");
const utils_1 = require("../../../utils");
const transformMonth = (date = new Date(Date.now()), monthDiff) => {
    const newDate = new Date(date);
    newDate.setDate(1);
    newDate.setMonth(newDate.getMonth() + monthDiff);
    return newDate;
};
const chooseDateToSet = (activeDateInput, newDate, dateRange = {}) => {
    const { from, to } = dateRange;
    if (newDate) {
        if (from && newDate < from) {
            return 'from';
        }
        else if (to && newDate > to) {
            return 'to';
        }
    }
    return activeDateInput;
};
const isDateRangeInView = (dateRange, viewMonth) => {
    if (!dateRange.from || !dateRange.to) {
        return false;
    }
    const monthOneTimestamp = viewMonth.getTime();
    const monthTwoTimestamp = transformMonth(viewMonth, 2).getTime();
    const fromTimestamp = dateRange.from.getTime();
    const toTimestamp = dateRange.to.getTime();
    if (fromTimestamp < monthOneTimestamp || toTimestamp >= monthTwoTimestamp) {
        return false;
    }
    return true;
};
exports.InputDateRange = ({ defaultValue = {}, locale = utils_1.Locales.English, onChange, onValidationFail, validationType, value, }) => {
    utils_1.useReadOnlyWarn('InputDateRange', value, onChange);
    const [dateRange, setDateRange] = react_1.useState(value || defaultValue);
    const [activeDateInput, setActiveDateInput] = react_1.useState('from');
    const [viewMonth, setViewMonth] = react_1.useState(value && value.from
        ? value.from
        : defaultValue && defaultValue.from
            ? defaultValue.from
            : new Date(Date.now()));
    const viewNextMonth = new Date(viewMonth);
    viewNextMonth.setMonth(viewNextMonth.getMonth() + 1);
    const [fromTextInputValue, setFromTextInputValue] = react_1.useState(utils_1.formatDateString(dateRange.from, locale));
    const [validFromDate, setValidFromDate] = react_1.useState(validationType !== 'error');
    const fromID = utils_1.useID();
    const [toTextInputValue, setToTextInputValue] = react_1.useState(utils_1.formatDateString(dateRange.to, locale));
    const [validToDate, setValidToDate] = react_1.useState(validationType !== 'error');
    const toID = utils_1.useID();
    const inputs = {
        from: {
            isValid: validFromDate,
            setIsValid: setValidFromDate,
            setValue: setFromTextInputValue,
            value: fromTextInputValue,
        },
        to: {
            isValid: validToDate,
            setIsValid: setValidToDate,
            setValue: setToTextInputValue,
            value: toTextInputValue,
        },
    };
    react_1.useEffect(() => {
        if (value && !isEqual_1.default(value, dateRange)) {
            setDateRange(value);
            value.from && inputs.from.setValue(utils_1.formatDateString(value.from, locale));
            value.to && inputs.to.setValue(utils_1.formatDateString(value.to, locale));
            value.from &&
                !isDateRangeInView(value, viewMonth) &&
                setViewMonth(value.from);
        }
    }, [inputs.from, inputs.to, value, onChange]);
    const toggleActiveDateInput = () => {
        if (activeDateInput === 'from') {
            setActiveDateInput('to');
        }
        else {
            setActiveDateInput('from');
        }
    };
    const handleDateChange = (dateToSet, date) => {
        const newDateRange = Object.assign(Object.assign({}, dateRange), { [dateToSet]: date });
        if (activeDateInput === 'from') {
            newDateRange.to = max_1.default(values_1.default(newDateRange));
            newDateRange.from = min_1.default(values_1.default(newDateRange));
        }
        else {
            newDateRange.from = min_1.default(values_1.default(newDateRange));
            newDateRange.to = max_1.default(values_1.default(newDateRange));
        }
        const nonActiveInput = dateToSet === 'from' ? 'to' : 'from';
        inputs[nonActiveInput].setValue(utils_1.formatDateString(newDateRange[nonActiveInput], locale));
        inputs.from.isValid || inputs.from.setIsValid(true);
        inputs.to.isValid || inputs.to.setIsValid(true);
        setDateRange(newDateRange);
        if (isFunction_1.default(onChange)) {
            onChange(newDateRange);
        }
    };
    const handleCalendarClick = (date) => {
        const dateToSet = chooseDateToSet(activeDateInput, date, dateRange);
        inputs[dateToSet].setValue(utils_1.formatDateString(date, locale));
        handleDateChange(dateToSet, date);
        if (dateToSet === activeDateInput) {
            toggleActiveDateInput();
        }
    };
    const handleTextInputChange = (e) => {
        const value = e.target.value;
        inputs[activeDateInput].setValue(value);
        if (value.length === 0) {
            handleDateChange(activeDateInput);
        }
        else {
            const parsedValue = utils_1.parseDateFromString(value, locale);
            if (parsedValue) {
                const newMonthFocus = activeDateInput === 'to'
                    ? transformMonth(parsedValue, -1)
                    : parsedValue;
                setViewMonth(newMonthFocus);
                handleDateChange(activeDateInput, parsedValue);
            }
        }
    };
    const handleValidation = (e) => {
        const value = e.target.value;
        const isValid = value.length === 0 || !!utils_1.parseDateFromString(value, locale);
        inputs[activeDateInput].setIsValid(isValid);
        if (!isValid && isFunction_1.default(onValidationFail)) {
            onValidationFail(value);
        }
    };
    const handleNextClick = () => {
        setViewMonth(transformMonth(viewMonth, 1));
    };
    const handlePrevClick = () => {
        setViewMonth(transformMonth(viewMonth, -1));
    };
    const handleNowClick = () => {
        setViewMonth(new Date(Date.now()));
    };
    const handleTextInputFocus = (label) => setActiveDateInput(label);
    const handleMonthChange = (viewMonthDiff, month) => {
        setViewMonth(transformMonth(month, viewMonthDiff));
    };
    return (react_1.default.createElement(InputDateRangeWrapper, null,
        react_1.default.createElement(MultiCalendarLayout, { px: "small" },
            react_1.default.createElement(InputTextWrapper, { active: activeDateInput === 'from', validationType: inputs.from.isValid ? undefined : 'error' },
                react_1.default.createElement(InputLabel, { active: activeDateInput === 'from', htmlFor: fromID }, "From:"),
                react_1.default.createElement(InputText_1.InputText, { placeholder: `Date (${utils_1.formatDateString(new Date(Date.now()), locale)})`, value: inputs.from.value, onChange: handleTextInputChange, onBlur: handleValidation, "data-testid": "date-from-text-input", id: fromID, onFocus: partial_1.default(handleTextInputFocus, 'from') })),
            react_1.default.createElement(InputTextWrapper, { active: activeDateInput === 'to', validationType: inputs.to.isValid ? undefined : 'error' },
                react_1.default.createElement(InputLabel, { active: activeDateInput === 'to', htmlFor: toID }, "To:"),
                react_1.default.createElement(InputText_1.InputText, { placeholder: `Date (${utils_1.formatDateString(new Date(Date.now()), locale)})`, value: inputs.to.value, onChange: handleTextInputChange, onBlur: handleValidation, "data-testid": "date-to-text-input", id: toID, onFocus: partial_1.default(handleTextInputFocus, 'to') }))),
        react_1.default.createElement(MultiCalendarLayout, null,
            react_1.default.createElement(CalendarWrapper, null,
                react_1.default.createElement(Calendar_1.Calendar, { selectedDates: dateRange, onDayClick: handleCalendarClick, locale: locale, viewMonth: viewMonth, onNowClick: handleNowClick, onPrevClick: handlePrevClick, showNextButton: false, onMonthChange: partial_1.default(handleMonthChange, 0) })),
            react_1.default.createElement(CalendarWrapper, null,
                react_1.default.createElement(Calendar_1.Calendar, { selectedDates: dateRange, onDayClick: handleCalendarClick, locale: locale, viewMonth: viewNextMonth, onNowClick: handleNowClick, onNextClick: handleNextClick, showPreviousButton: false, onMonthChange: partial_1.default(handleMonthChange, -1) })))));
};
const InputLabel = styled_components_1.default.label.withConfig({ displayName: "InputLabel", componentId: "sc-139v7is" }) `
  color: ${({ theme: { colors }, active }) => active
    ? colors.semanticColors.primary.main
    : colors.semanticColors.neutral.main};
  font-weight: bold;
  text-transform: uppercase;
  font-size: ${({ theme }) => theme.fontSizes.xsmall};
  border-top-left-radius: ${({ theme }) => theme.radii.medium};
  border-bottom-left-radius: ${({ theme }) => theme.radii.medium};
  padding: 0.5rem;
`;
const InputDateRangeWrapper = styled_components_1.default.div.withConfig({ displayName: "InputDateRangeWrapper", componentId: "sc-945wn2" }) `
  display: inline-block;
`;
const MultiCalendarLayout = styled_components_1.default.div.withConfig({ displayName: "MultiCalendarLayout", componentId: "sc-10486gi" }) `
  ${design_tokens_1.space}
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-column-gap: ${({ theme }) => theme.space.large};
`;
const InputTextWrapper = styled_components_1.default.div.withConfig({ displayName: "InputTextWrapper", componentId: "sc-9b37ns" }) `
  ${design_tokens_1.border}
  ${design_tokens_1.color}

  display: grid;
  grid-template-columns: auto 1fr;
  align-items: center;
  margin-bottom: 1rem;

  &:hover {
    ${InputText_1.inputTextHover}
  }

  &:focus-within {
    ${InputText_1.inputTextFocus}
  }

  ${InputText_1.inputTextValidation}

  ${InputText_1.InputText} {
    border: none;
    border-radius: 0;
    padding: 0;
    margin: 0;
    box-shadow: none;
    background: transparent;
  }
`;
InputTextWrapper.defaultProps = Object.assign({}, InputText_1.inputTextDefaults);
const CalendarWrapper = styled_components_1.default.div.withConfig({ displayName: "CalendarWrapper", componentId: "sc-v58xsf" }) `
  ${Calendar_1.Calendar} {
    padding: 0;
  }
`;
//# sourceMappingURL=InputDateRange.js.map