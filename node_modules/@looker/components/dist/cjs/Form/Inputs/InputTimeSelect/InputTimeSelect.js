"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const styled_components_1 = __importDefault(require("styled-components"));
const reduce_1 = __importDefault(require("lodash/reduce"));
const map_1 = __importDefault(require("lodash/map"));
const isFunction_1 = __importDefault(require("lodash/isFunction"));
const find_1 = __importDefault(require("lodash/find"));
const trim_1 = __importDefault(require("lodash/trim"));
const last_1 = __importDefault(require("lodash/last"));
const head_1 = __importDefault(require("lodash/head"));
const sortedIndex_1 = __importDefault(require("lodash/sortedIndex"));
const Combobox_1 = require("../Combobox");
const utils_1 = require("../../../utils");
const utils_2 = require("../utils");
const cycleHourDisplay = (format, hour) => {
    if (format === '12h') {
        if (hour === 0) {
            return 12;
        }
        else if (hour > 12) {
            return hour - 12;
        }
    }
    return hour;
};
const formatLabel = (format, hour, minute) => {
    const formattedHour = utils_2.formatTimeString(cycleHourDisplay(format, hour));
    const formattedMinute = utils_2.formatTimeString(minute);
    const period = format === '12h' && (hour < 12 ? 'am' : 'pm');
    return trim_1.default(`${formattedHour}:${formattedMinute} ${period || ''}`);
};
const generateMinuteIntervals = (interval) => {
    const minutes = new Array(60 / interval);
    return map_1.default(minutes, (_, index) => utils_2.formatTimeString(index * interval));
};
const generateTimes = (format, interval) => {
    const hours = new Array(24);
    const minutes = generateMinuteIntervals(interval);
    return reduce_1.default(hours, (result, _, hour) => {
        const formatLabel = format === '12h' && (hour < 12 ? 'am' : 'pm');
        const formattedHour = utils_2.formatTimeString(cycleHourDisplay(format, hour));
        const hourWithMinutes = map_1.default(minutes, (minute) => {
            const label = trim_1.default(`${formattedHour}:${minute} ${formatLabel || ''}`);
            const value = `${utils_2.formatTimeString(hour)}:${minute}`;
            return {
                label,
                value,
            };
        });
        return [...result, ...hourWithMinutes];
    }, []);
};
const matchClosestMinute = (interval, timeCode) => {
    const minuteOptions = map_1.default(generateMinuteIntervals(interval), utils_2.parseBase10Int);
    const now = new Date(Date.now());
    const currentMinute = timeCode
        ? utils_2.parseBase10Int(timeCode.split(':')[1])
        : now.getMinutes();
    const currentHour = timeCode
        ? utils_2.parseBase10Int(timeCode.split(':')[0])
        : now.getHours();
    const index = sortedIndex_1.default(minuteOptions, currentMinute);
    const optionBefore = minuteOptions[index - 1] || head_1.default(minuteOptions);
    const optionAfter = minuteOptions[index] || last_1.default(minuteOptions);
    const roundedMinute = currentMinute - optionBefore < optionAfter - currentMinute
        ? optionBefore
        : optionAfter;
    const formattedHour = utils_2.formatTimeString(currentHour);
    const formattedMinute = utils_2.formatTimeString(roundedMinute);
    return `${formattedHour}:${formattedMinute}`;
};
const createOptionFromStringValue = (format, value) => {
    const [hour, minute] = map_1.default(value.split(':'), utils_2.parseBase10Int);
    return {
        label: formatLabel(format, hour, minute),
        value,
    };
};
const createOptionFromLabel = (format, label) => {
    const period = label.toLowerCase().includes('p') ? 'pm' : 'am';
    const numericTime = label.replace(/[apm]/gi, '');
    const [hour = 0, minute = 0] = numericTime.split(':').map(utils_2.parseBase10Int);
    const hr24 = hour + (period === 'pm' ? 12 : 0);
    const value = `${utils_2.formatTimeString(hr24)}:${utils_2.formatTimeString(minute)}`;
    if (utils_2.isValidTime(value)) {
        return { label: formatLabel(format, hr24, minute), value };
    }
    return undefined;
};
const matchStringValueToOption = (options, format, value) => {
    if (value && utils_2.isValidTime(value)) {
        const option = find_1.default(options, { value: value });
        return option || createOptionFromStringValue(format, value);
    }
    return undefined;
};
const matchStringLabelToOption = (options, label) => {
    if (label) {
        return find_1.default(options, (o) => {
            return o.label ? o.label.includes(label) : false;
        });
    }
    return undefined;
};
const setScrollIntoView = (options, interval, selectedOption) => {
    if (selectedOption) {
        return map_1.default(options, (option) => matchClosestMinute(interval, selectedOption.value) === option.value
            ? Object.assign(Object.assign({}, option), { scrollIntoView: true }) : option);
    }
    const now = matchClosestMinute(interval);
    return map_1.default(options, (option) => option.value === now ? Object.assign(Object.assign({}, option), { scrollIntoView: true }) : option);
};
exports.InputTimeSelect = ({ interval = 15, format = '12h', onChange, value = '', defaultValue, }) => {
    utils_1.useReadOnlyWarn('InputTimeSelect', value, onChange);
    const valueProp = value || defaultValue;
    if (!utils_2.isValidTime(valueProp)) {
        console.error(`Invalid time ("${valueProp}") passed to <InputTimeSelect />. Value should be formatted as a 24-hour string (e.g. value="02:00" or value="23:15").`);
    }
    const timeOptions = generateTimes(format, interval);
    const [selectedOption, setSelectedOption] = react_1.useState();
    const [inputTextValue, setInputTextValue] = react_1.useState('');
    react_1.useEffect(() => {
        setSelectedOption(matchStringValueToOption(timeOptions, format, value || defaultValue));
    }, [value]);
    const handleChange = (newSelectedOption) => {
        setSelectedOption(newSelectedOption);
        const newValue = newSelectedOption ? newSelectedOption.value : undefined;
        if (isFunction_1.default(onChange) && utils_2.isValidTime(newValue)) {
            onChange(newValue);
        }
    };
    const handleTextInputChange = (e) => {
        setInputTextValue(e.target.value);
    };
    const handleTextInputBlur = () => {
        setInputTextValue('');
    };
    const handleKeyDown = (e) => {
        if (e.key === 'Enter') {
            if (inputTextValue.length) {
                const option = createOptionFromLabel(format, inputTextValue);
                handleChange(option);
            }
        }
    };
    const optionToFocus = matchStringLabelToOption(timeOptions, inputTextValue) || selectedOption;
    const timeOptionsFocused = setScrollIntoView(timeOptions, interval, optionToFocus);
    return (react_1.default.createElement(InputTimeSelectWrapper, null,
        react_1.default.createElement(Combobox_1.Combobox, { value: selectedOption, onChange: handleChange },
            react_1.default.createElement(Combobox_1.ComboboxInput, { placeholder: "Select time", onChange: handleTextInputChange, onBlur: handleTextInputBlur, onKeyDown: handleKeyDown, autoComplete: false }),
            react_1.default.createElement(Combobox_1.ComboboxList, { persistSelection: true }, timeOptionsFocused.map((option, index) => (react_1.default.createElement(Combobox_1.ComboboxOption, Object.assign({}, option, { key: index }))))))));
};
const InputTimeSelectWrapper = styled_components_1.default.div.withConfig({ displayName: "InputTimeSelectWrapper", componentId: "sc-1v9yb70" }) `
  display: inline-block;
`;
//# sourceMappingURL=InputTimeSelect.js.map