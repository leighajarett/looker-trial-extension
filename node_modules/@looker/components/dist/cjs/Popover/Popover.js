"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const Layout_1 = require("../Layout");
const Modal_1 = require("../Modal");
const OverlaySurface_1 = require("../Overlay/OverlaySurface");
const utils_1 = require("../utils");
function useVerticalSpace(element, pin, placement, isOpen) {
    const [spaceTop, setSpaceTop] = react_1.useState(0);
    const [spaceBottom, setSpaceBottom] = react_1.useState(0);
    const placementIsBottom = placement && placement.includes('bottom');
    const placementIsTop = placement && placement.includes('top');
    react_1.useEffect(() => {
        function getVerticalSpace() {
            if (element) {
                if (placementIsBottom || placementIsTop) {
                    const { top, bottom } = element.getBoundingClientRect();
                    if (!pin || placementIsTop) {
                        setSpaceTop(top);
                    }
                    else if (pin) {
                        setSpaceTop(0);
                    }
                    if (!pin || placementIsBottom) {
                        setSpaceBottom(window.innerHeight - bottom);
                    }
                    else if (pin) {
                        setSpaceBottom(0);
                    }
                }
                else {
                    setSpaceTop(window.innerHeight);
                }
            }
        }
        if (isOpen) {
            window.addEventListener('resize', getVerticalSpace);
            getVerticalSpace();
        }
        return () => {
            window.removeEventListener('resize', getVerticalSpace);
        };
    }, [element, pin, placementIsBottom, placementIsTop, isOpen]);
    const max = Math.max(spaceTop, spaceBottom);
    const windowHeight = typeof window !== `undefined` ? window.innerHeight : 50;
    return max > 50 ? max : windowHeight;
}
function useOpenWithoutElement(isOpen, element) {
    const [openWithoutElem, setOpenWithoutElem] = react_1.useState(isOpen && element === null);
    react_1.useEffect(() => {
        if (element && openWithoutElem) {
            setOpenWithoutElem(false);
        }
    }, [openWithoutElem, element]);
    return openWithoutElem;
}
function isNodeInOrAfter(nodeA, nodeB) {
    const relationship = nodeA.compareDocumentPosition(nodeB);
    return (relationship === Node.DOCUMENT_POSITION_FOLLOWING ||
        relationship ===
            Node.DOCUMENT_POSITION_FOLLOWING + Node.DOCUMENT_POSITION_CONTAINED_BY);
}
function usePopoverToggle({ isOpen: controlledIsOpen = false, setOpen: controlledSetOpen, canClose, groupedPopoversRef, triggerToggle, }, portalElement, triggerElement) {
    const [uncontrolledIsOpen, uncontrolledSetOpen] = react_1.useState(controlledIsOpen);
    const [mouseDownTarget, setMouseDownTarget] = react_1.useState(null);
    const isControlled = utils_1.useControlWarn({
        controllingProps: ['setOpen'],
        isControlledCheck: () => controlledSetOpen !== undefined,
        name: 'usePopover',
    });
    const isOpen = isControlled ? controlledIsOpen : uncontrolledIsOpen;
    const setOpen = isControlled && controlledSetOpen ? controlledSetOpen : uncontrolledSetOpen;
    react_1.useEffect(() => {
        function checkCloseAndStopEvent(event) {
            if (canClose && !canClose())
                return;
            if (portalElement && mouseDownTarget) {
                if (isNodeInOrAfter(portalElement, mouseDownTarget)) {
                    return;
                }
            }
            if (portalElement &&
                isNodeInOrAfter(portalElement, event.target)) {
                return;
            }
            const clickedOnToggle = triggerElement && triggerElement.contains(event.target);
            if (!triggerToggle && clickedOnToggle) {
                return;
            }
            setOpen(false);
            if (clickedOnToggle) {
                event.stopPropagation();
                return;
            }
            if (groupedPopoversRef &&
                groupedPopoversRef.current &&
                groupedPopoversRef.current.contains(event.target)) {
                return;
            }
            event.stopPropagation();
            event.preventDefault();
        }
        function handleMouseDown(event) {
            setMouseDownTarget(event.target);
            checkCloseAndStopEvent(event);
        }
        function handleClickOutside(event) {
            checkCloseAndStopEvent(event);
            setMouseDownTarget(null);
        }
        function handleMouseUp() {
            setMouseDownTarget(null);
        }
        if (isOpen) {
            document.addEventListener('mousedown', handleMouseDown, true);
            document.addEventListener('click', handleClickOutside, true);
        }
        else if (mouseDownTarget) {
            document.addEventListener('click', handleClickOutside, true);
            document.addEventListener('mouseup', handleMouseUp, true);
        }
        return () => {
            document.removeEventListener('mousedown', handleMouseDown, true);
            document.removeEventListener('click', handleClickOutside, true);
            document.removeEventListener('mouseup', handleMouseUp, true);
        };
    }, [
        canClose,
        groupedPopoversRef,
        isOpen,
        setOpen,
        triggerElement,
        portalElement,
        triggerToggle,
        mouseDownTarget,
    ]);
    return [isOpen, setOpen];
}
function usePopover({ arrow = true, canClose, content, groupedPopoversRef, pin = false, isOpen: controlledIsOpen = false, onClose, placement: propsPlacement = 'bottom', setOpen: controlledSetOpen, triggerElement, triggerToggle = true, focusTrap = true, }) {
    const { element: scrollElement, callbackRef: scrollRef, enable: enableScrollLock, isEnabled: scrollLockEnabled, disable: disableScrollLock, } = utils_1.useScrollLock(controlledIsOpen, true);
    const { callbackRef: focusRef, enable: enableFocusTrap, isEnabled: focusTrapEnabled, disable: disableFocusTrap, trapRef: focusTrapRef, } = utils_1.useFocusTrap(controlledIsOpen && focusTrap);
    const { focusTrapRef: parentFocusTrapRef } = react_1.default.useContext(Modal_1.ModalContext);
    const [newTriggerElement, callbackRef] = utils_1.useCallbackRef();
    const element = typeof triggerElement === 'undefined' ? newTriggerElement : triggerElement;
    const [isOpen, setOpen] = usePopoverToggle({
        canClose,
        groupedPopoversRef,
        isOpen: controlledIsOpen,
        setOpen: controlledSetOpen,
        triggerToggle,
    }, scrollElement, element);
    const verticalSpace = useVerticalSpace(element, pin, propsPlacement, isOpen);
    const openWithoutElem = useOpenWithoutElement(isOpen, element);
    react_1.useEffect(() => {
        if (isOpen) {
            if (focusTrap) {
                enableFocusTrap();
            }
            else {
                parentFocusTrapRef &&
                    parentFocusTrapRef.current &&
                    parentFocusTrapRef.current.deactivate({ returnFocus: false });
            }
        }
    }, [focusTrap, parentFocusTrapRef, isOpen, enableFocusTrap]);
    function handleOpen(event) {
        setOpen(true);
        enableScrollLock();
        event.stopPropagation();
        event.preventDefault();
    }
    function handleClose() {
        if (canClose && !canClose())
            return;
        setOpen(false);
        onClose && onClose();
    }
    const usePopperProps = react_1.useMemo(() => ({
        anchor: element,
        arrow,
        options: {
            modifiers: [
                {
                    enabled: !pin,
                    name: 'flip',
                    options: {
                        flipVariations: true,
                        flipVariationsByContent: true,
                    },
                },
                {
                    enabled: true,
                    name: 'eventListeners',
                    options: {
                        scroll: false,
                    },
                },
            ],
            placement: propsPlacement,
        },
    }), [arrow, element, pin, propsPlacement]);
    const { arrowProps, placement, popperInstanceRef, style, targetRef, } = utils_1.usePopper(usePopperProps);
    const ref = utils_1.useForkedRef(targetRef, focusRef);
    const [containerElement, contentContainerRef] = utils_1.useCallbackRef();
    const popover = !openWithoutElem && isOpen && (react_1.default.createElement(Modal_1.ModalContext.Provider, { value: {
            closeModal: handleClose,
            disableFocusTrap,
            disableScrollLock,
            enableFocusTrap,
            enableScrollLock,
            focusTrapEnabled,
            focusTrapRef,
            scrollLockEnabled,
        } },
        react_1.default.createElement(Modal_1.ModalPortal, { ref: scrollRef },
            react_1.default.createElement(OverlaySurface_1.OverlaySurface, { arrow: arrow, arrowProps: arrowProps, placement: placement, ref: ref, style: style, backgroundColor: "palette.white", border: "1px solid", borderColor: "palette.charcoal200", borderRadius: "medium", boxShadow: 3, color: "palette.charcoal900" },
                react_1.default.createElement(Layout_1.Box, { maxHeight: `calc(${verticalSpace - 10}px - 1rem)`, overflowY: "auto", borderRadius: "inherit", ref: contentContainerRef }, content)))));
    return {
        contentContainer: containerElement,
        isOpen,
        open: handleOpen,
        popover,
        popperInstanceRef,
        ref: callbackRef,
    };
}
exports.usePopover = usePopover;
function Popover(_a) {
    var { children, hoverDisclosureRef } = _a, props = __rest(_a, ["children", "hoverDisclosureRef"]);
    const { popover, open, ref, isOpen } = usePopover(props);
    const childrenOutput = children(open, ref, isOpen ? 'active' : '');
    const [isHovered] = utils_1.useHovered(hoverDisclosureRef);
    const triggerShown = isHovered || isOpen;
    return (react_1.default.createElement(react_1.default.Fragment, null,
        popover,
        triggerShown && childrenOutput));
}
exports.Popover = Popover;
//# sourceMappingURL=Popover.js.map