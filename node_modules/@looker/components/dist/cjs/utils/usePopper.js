"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const concat_1 = __importDefault(require("lodash/concat"));
const merge_1 = __importDefault(require("lodash/merge"));
const react_1 = require("react");
const core_1 = require("@popperjs/core");
const getCurrentNode_1 = require("./getCurrentNode");
const useCallbackRef_1 = require("./useCallbackRef");
function usePopper({ anchor, target, arrow = true, options, }) {
    const [styles, setStyles] = react_1.useState({
        arrow: {
            position: 'absolute',
        },
        popper: {
            left: '0',
            margin: '0',
            position: 'fixed',
            top: '0',
        },
    });
    const [truePlacement, setTruePlacement] = react_1.useState(options.placement);
    const popperInstanceRef = react_1.useRef();
    const [targetElement, targetRef] = useCallbackRef_1.useCallbackRef();
    const [arrowElement, arrowRef] = useCallbackRef_1.useCallbackRef();
    const mergedOptions = react_1.useMemo(() => merge_1.default(options, {
        modifiers: concat_1.default(options && options.modifiers, [
            ...(arrow
                ? [
                    {
                        name: 'arrow',
                        options: { element: arrowElement, padding: 5 },
                    },
                ]
                : []),
            {
                enabled: false,
                name: 'applyStyles',
            },
            {
                enabled: true,
                fn: ({ state: { placement } }) => setTruePlacement(placement),
                name: 'update-placement',
                phase: 'afterWrite',
            },
            {
                enabled: true,
                fn: ({ state: { styles } }) => setStyles(cloneDeep_1.default(styles)),
                name: 'update-styles',
                phase: 'afterWrite',
            },
            {
                enabled: true,
                name: 'preventOverflow',
                options: {
                    boundary: 'viewport',
                    padding: 8,
                },
            },
            {
                name: 'offset',
                options: {
                    offset: [0, 8],
                },
            },
            {
                name: 'computeStyles',
                options: {
                    adaptive: false,
                },
            },
        ]),
        strategy: 'fixed',
    }), [arrow, arrowElement, options]);
    react_1.useEffect(() => {
        const anchorNode = getCurrentNode_1.getCurrentNode(anchor);
        const targetNode = target ? getCurrentNode_1.getCurrentNode(target) : targetElement;
        if (anchorNode && targetNode) {
            popperInstanceRef.current = core_1.createPopper(anchorNode, targetNode, mergedOptions);
        }
        return () => {
            popperInstanceRef.current && popperInstanceRef.current.destroy();
        };
    }, [anchor, target, targetElement, arrow, arrowElement, mergedOptions]);
    return {
        arrowProps: { ref: arrowRef, style: styles.arrow },
        placement: truePlacement,
        popperInstanceRef,
        style: styles.popper,
        targetRef,
    };
}
exports.usePopper = usePopper;
//# sourceMappingURL=usePopper.js.map