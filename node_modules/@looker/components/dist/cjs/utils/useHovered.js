"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("react");
const getCurrentNode_1 = require("./getCurrentNode");
const useCallbackRef_1 = require("./useCallbackRef");
function useHovered(hoverElement) {
    const [newElement, callbackRef] = useCallbackRef_1.useCallbackRef();
    const element = typeof hoverElement === 'undefined' ? newElement : hoverElement;
    const [isHovered, setIsHovered] = react_1.useState(hoverElement === undefined);
    react_1.useEffect(() => {
        function handleMouseEnter() {
            setIsHovered(true);
        }
        function handleMouseLeave() {
            window.requestAnimationFrame(() => {
                const node = getCurrentNode_1.getCurrentNode(element);
                const relationship = node.compareDocumentPosition(document.activeElement);
                const activeElementIsChildOfNode = relationship ===
                    Node.DOCUMENT_POSITION_FOLLOWING + Node.DOCUMENT_POSITION_CONTAINED_BY;
                if (!activeElementIsChildOfNode)
                    setIsHovered(false);
            });
        }
        const node = getCurrentNode_1.getCurrentNode(element);
        if (node) {
            node.addEventListener('mouseleave', handleMouseLeave);
            node.addEventListener('mouseenter', handleMouseEnter);
            node.addEventListener('focusout', handleMouseLeave);
            node.addEventListener('focusin', handleMouseEnter);
        }
        return () => {
            if (node) {
                node.removeEventListener('mouseleave', handleMouseLeave);
                node.removeEventListener('mouseenter', handleMouseEnter);
                node.removeEventListener('focusout', handleMouseLeave);
                node.removeEventListener('focusin', handleMouseEnter);
            }
        };
    }, [element]);
    return [isHovered, callbackRef];
}
exports.useHovered = useHovered;
//# sourceMappingURL=useHovered.js.map