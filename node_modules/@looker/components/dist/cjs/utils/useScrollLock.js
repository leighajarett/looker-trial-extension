"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const once_1 = __importDefault(require("lodash/once"));
const react_1 = require("react");
const ModalContext_1 = require("../Modal/ModalContext");
const useToggle_1 = require("./useToggle");
const useCallbackRef_1 = require("./useCallbackRef");
function setBodyOverflowHidden() {
    if (typeof document !== 'undefined') {
        document.body.style.overflow = 'hidden';
    }
}
function useScrollLock(enabled = false, useCapture = false, allowScrollWithin) {
    const [newElement, callbackRef] = useCallbackRef_1.useCallbackRef();
    const element = typeof allowScrollWithin === 'undefined' ? newElement : allowScrollWithin;
    const { disableScrollLock, enableScrollLock } = react_1.useContext(ModalContext_1.ModalContext);
    const { value, setOn, setOff } = useToggle_1.useToggle(enabled);
    const bodyOverflowRef = react_1.useRef(typeof document !== 'undefined' ? document.body.style.overflow : '');
    react_1.useEffect(() => {
        if (typeof document === 'undefined' || typeof window === 'undefined')
            return;
        let scrollTop = window.scrollY;
        let scrollTarget = document;
        const bodyOverflowCurrent = bodyOverflowRef.current;
        const setBodyOverflowOnce = once_1.default(setBodyOverflowHidden);
        function stopScroll(e) {
            setBodyOverflowOnce();
            if (e.target !== null && e.target !== scrollTarget) {
                scrollTarget = e.target;
                scrollTop =
                    scrollTarget instanceof Element
                        ? scrollTarget.scrollTop
                        : window.scrollY;
            }
            if (scrollTarget instanceof Element &&
                !(element && element.contains(scrollTarget))) {
                scrollTarget.scrollTop = scrollTop;
            }
            else if (scrollTarget === document) {
                window.scrollTo({ top: scrollTop });
            }
        }
        if (element && value) {
            window.addEventListener('scroll', stopScroll, true);
            disableScrollLock && disableScrollLock();
            setBodyOverflowHidden();
        }
        else {
            window.removeEventListener('scroll', stopScroll, true);
            enableScrollLock && enableScrollLock();
            document.body.style.overflow = bodyOverflowCurrent;
        }
        return () => {
            window.removeEventListener('scroll', stopScroll, true);
            document.body.style.overflow = bodyOverflowCurrent;
        };
    }, [value, element, useCapture, disableScrollLock, enableScrollLock]);
    return {
        callbackRef,
        disable: setOff,
        element: element || null,
        enable: setOn,
        isEnabled: value,
    };
}
exports.useScrollLock = useScrollLock;
//# sourceMappingURL=useScrollLock.js.map